using Unity.Entities;
using Unity.Mathematics;
using System;
using System.Runtime.CompilerServices;

namespace KBVE.MMExtensions.Orchestrator.DOTS
{
    
    /// <summary>
    /// Core entity data - type, faction, and basic stats
    /// </summary>
    public struct EntityCore : IComponentData
    {
        public EntityType type;
        public FactionType faction;
        public float health;
        public float maxHealth;
        public float speed;
        public float baseSpeed;

        public static EntityCore CreateZombie(float health = 100f, float speed = 3f)
        {
            return new EntityCore
            {
                type = EntityType.Zombie,
                faction = FactionType.Enemy,
                health = health,
                maxHealth = health,
                speed = speed,
                baseSpeed = speed
            };
        }
    }

    /// <summary>
    /// Movement and destination data - optimized for 2D
    /// </summary>
    public struct Movement : IComponentData
    {
        public float3 destination;      // Still float3 for world position compatibility
        public float2 facingDirection;  // 2D direction
        public float2 velocity;          // 2D velocity
        public float stoppingDistance;
        public float arrivalThreshold;

        public static Movement CreateDefault(float stoppingDistance = 2f)
        {
            return new Movement
            {
                destination = float3.zero,
                facingDirection = new float2(1, 0),
                velocity = float2.zero,
                stoppingDistance = stoppingDistance,
                arrivalThreshold = stoppingDistance * stoppingDistance // Pre-squared for efficiency
            };
        }
    }

    /// <summary>
    /// Navigation and targeting data
    /// </summary>
    public struct NavigationData : IComponentData
    {
        public Entity targetEntity;
        public float3 lastKnownTargetPos;
        public float scanRadius;
        public float updateInterval;
        public float lastUpdate;
        public int waypointIndex;
        public int pathVersion;

        public static NavigationData CreateDefault(float scanRadius = 15f)
        {
            return new NavigationData
            {
                targetEntity = Entity.Null,
                lastKnownTargetPos = float3.zero,
                scanRadius = scanRadius,
                updateInterval = 1f,
                lastUpdate = 0f,
                waypointIndex = -1,
                pathVersion = 0
            };
        }
    }

    /// <summary>
    /// Avoidance and collision data - kept separate for performance
    /// </summary>
    public struct AvoidanceData : IComponentData
    {
        public float personalSpace;
        public float3 avoidanceVector;
        public float speedVariation;
        public float lastAvoidanceUpdate;

        public static AvoidanceData CreateDefault(float personalSpace = 2f)
        {
            return new AvoidanceData
            {
                personalSpace = personalSpace,
                avoidanceVector = float3.zero,
                speedVariation = 1f,
                lastAvoidanceUpdate = 0f
            };
        }
    }

    /// <summary>
    /// Entity type enumeration
    /// </summary>
    public enum EntityType : byte
    {
        None = 0,
        Player = 1,
        Zombie = 2,
        NPC = 3,
        Building = 4,
        Projectile = 5
    }

    /// <summary>
    /// Static helper methods for state management with aggressive inlining
    /// </summary>
    public static class StateHelpers
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void SetMovementState(ref EntityState state, EntityStateFlags newMovement, float time)
        {
            state.flags = (state.flags & ~EntityStateFlags.MovementMask) | (newMovement & EntityStateFlags.MovementMask);
            state.lastStateChange = time;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static EntityStateFlags GetMovementState(in EntityState state)
        {
            return state.flags & EntityStateFlags.MovementMask;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPatrolling(in EntityState state)
        {
            return (state.flags & EntityStateFlags.Patrolling) != 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool HasTarget(in EntityState state)
        {
            return (state.flags & EntityStateFlags.HasTarget) != 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInCombat(in EntityState state)
        {
            return (state.flags & EntityStateFlags.InCombat) != 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void AddFlag(ref EntityState state, EntityStateFlags flag)
        {
            state.flags |= flag;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void RemoveFlag(ref EntityState state, EntityStateFlags flag)
        {
            state.flags &= ~flag;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool HasFlag(in EntityState state, EntityStateFlags flag)
        {
            return (state.flags & flag) == flag;
        }
    }
}