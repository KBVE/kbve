using System;
using UnityEngine;
using OneJS;
using R3;
using VContainer;
using VContainer.Unity;
using KBVE.SSDB.IRC;
using Cysharp.Threading.Tasks;
using System.Threading;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// OneJS Bridge for IRC service
/// This class should be attached to a GameObject in the scene for OneJS to reference
/// It syncs with the VContainer-injected IRCService instance
/// Uses simpler namespace for OneJS Source Generator compatibility
/// </summary>
public partial class IRCBridge : MonoBehaviour
{
    private IIRCService _ircService;
    private readonly CompositeDisposable _disposables = new();
    
    #region OneJS EventfulProperty Fields
    
    // EventfulProperty fields for OneJS bidirectional binding
    // OneJS Source Generator will auto-create properties and events
    [EventfulProperty] bool _jsIsConnected = false;
    [EventfulProperty] string _jsConnectionState = "Disconnected";
    [EventfulProperty] string _jsCurrentChannel = string.Empty;
    [EventfulProperty] string _jsCurrentNickname = string.Empty;
    [EventfulProperty] int _jsPendingMessages = 0;
    [EventfulProperty] string _jsLastMessage = string.Empty;
    [EventfulProperty] string _jsLastError = string.Empty;
    [EventfulProperty] string _jsLastRawMessage = string.Empty;
    [EventfulProperty] List<string> _jsRecentMessages = new();
    [EventfulProperty] List<string> _jsChannelUsers = new();
    
    // Auto-generated by EventfulProperty:
    // - public bool JsIsConnected { get; set; }
    // - public event Action<bool> OnJsIsConnectedChanged;
    // - etc. for all fields above
    
    #endregion

    #region Configuration
    
    // Configuration that can be set from Unity Inspector or OneJS
    [Header("IRC Configuration")]
    [SerializeField] private string server = "irc.kbve.com";
    [SerializeField] private int port = 6697;
    [SerializeField] private bool useSsl = true;
    [SerializeField] private string defaultChannel = "#general";
    [SerializeField] private bool autoConnect = false;
    [SerializeField] private int maxRecentMessages = 100;
    
    #endregion

    #region Unity Lifecycle
    
    private void Start()
    {
        // Find the IRCService instance from VContainer using UniTask
        InitializeIRCConnection().Forget();
    }
    
    private void OnDestroy()
    {
        _disposables.Dispose();
    }
    
    #endregion
    
    #region Initialization
    
    private async UniTaskVoid InitializeIRCConnection()
    {
        try
        {
            // Use UniTask for non-blocking async initialization
            await WaitForIRCServiceAsync();
        }
        catch (OperationCanceledException)
        {
            Debug.LogWarning("[IRCBridge] IRC connection initialization was cancelled or timed out");
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Failed to initialize IRC connection: {ex.Message}");
        }
    }
    
    private async UniTask WaitForIRCServiceAsync()
    {
        // Set a 30-second timeout for finding IRCService
        using var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
        var destroyCancellationToken = this.GetCancellationTokenOnDestroy();
        
        // Combine timeout and destroy tokens
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            timeoutCts.Token, 
            destroyCancellationToken
        );
        
        Debug.Log("[IRCBridge] Starting async search for IRCService...");
        
        while (_ircService == null)
        {
            linkedCts.Token.ThrowIfCancellationRequested();
            
            try
            {
                // Try to find it through VContainer's resolver
                var lifetimeScope = FindAnyObjectByType<LifetimeScope>();
                if (lifetimeScope != null && lifetimeScope.Container != null)
                {
                    if (lifetimeScope.Container.TryResolve<IIRCService>(out var ircService))
                    {
                        _ircService = ircService;
                        Debug.Log("[IRCBridge] Found IRCService through VContainer");
                        InitializeBindings();
                        
                        // Auto-connect if configured
                        if (autoConnect)
                        {
                            await JsConnectAsync();
                        }
                        return;
                    }
                }
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[IRCBridge] Error finding IRCService: {ex.Message}");
            }
            
            // Non-blocking delay using UniTask
            await UniTask.Delay(500, cancellationToken: linkedCts.Token);
        }
    }
    
    #endregion
    
    #region Data Binding
    
    private void InitializeBindings()
    {
        if (_ircService == null) return;
        
        Debug.Log("[IRCBridge] Initializing OneJS bindings with IRCService");
        
        // Subscribe to all reactive properties from IRCService
        _ircService.IsConnected.Subscribe(value => 
        {
            JsIsConnected = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _ircService.CurrentChannel.Subscribe(value => 
        {
            JsCurrentChannel = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _ircService.CurrentNickname.Subscribe(value => 
        {
            JsCurrentNickname = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _ircService.PendingMessages.Subscribe(value => 
        {
            JsPendingMessages = value; // Auto-generated property
        }).AddTo(_disposables);
        
        // Subscribe to connection state changes
        _ircService.OnConnectionStateChanged.Subscribe(state => 
        {
            JsConnectionState = state.ToString(); // Auto-generated property
        }).AddTo(_disposables);
        
        // Subscribe to messages
        _ircService.OnMessageReceived.Subscribe(message => 
        {
            ProcessIncomingMessage(message);
        }).AddTo(_disposables);
        
        // Subscribe to errors
        _ircService.OnError.Subscribe(error => 
        {
            JsLastError = error; // Auto-generated property
            Debug.LogWarning($"[IRCBridge] IRC Error: {error}");
        }).AddTo(_disposables);
        
        // Subscribe to raw messages (optional, for debugging)
        _ircService.OnRawMessageReceived.Subscribe(raw => 
        {
            JsLastRawMessage = raw; // Auto-generated property
        }).AddTo(_disposables);
    }
    
    private void ProcessIncomingMessage(IRCMessage message)
    {
        // Format the message for display
        var formattedMessage = FormatMessage(message);
        JsLastMessage = formattedMessage;
        
        // Add to recent messages list
        _jsRecentMessages ??= new List<string>();
            
        _jsRecentMessages.Add(formattedMessage);
        
        // Keep only the most recent messages
        while (_jsRecentMessages.Count > maxRecentMessages)
        {
            _jsRecentMessages.RemoveAt(0);
        }
        
        // Trigger the property change event
        JsRecentMessages = new List<string>(_jsRecentMessages);
        
        // Update channel users if it's a JOIN/PART/QUIT message
        if (message.command == "JOIN" || message.command == "PART" || message.command == "QUIT")
        {
            // This would need additional implementation to track users
            UpdateChannelUsers();
        }
    }
    
    private string FormatMessage(IRCMessage message)
    {
        if (message.isChannelMessage || message.isPrivateMessage)
        {
            return $"[{message.timestamp:HH:mm:ss}] <{message.nickname}> {message.message}";
        }
        else if (message.isServerMessage)
        {
            return $"[{message.timestamp:HH:mm:ss}] * {message.message}";
        }
        else
        {
            return $"[{message.timestamp:HH:mm:ss}] {message.rawMessage}";
        }
    }
    
    private void UpdateChannelUsers()
    {
        // This would need to be implemented based on your IRC protocol handling
        // For now, just trigger an update event
        JsChannelUsers = new List<string>(_jsChannelUsers ?? new List<string>());
    }
    
    #endregion
    
    #region OneJS Public Methods - Connection Management
    
    /// <summary>
    /// Connect to IRC server asynchronously
    /// </summary>
    public async UniTask<bool> JsConnectAsync()
    {
        if (_ircService == null)
        {
            Debug.LogError("[IRCBridge] IRCService not available");
            return false;
        }
        
        try
        {
            Debug.Log($"[IRCBridge] Connecting to IRC server...");
            var result = await _ircService.ConnectAsync(this.GetCancellationTokenOnDestroy());
            Debug.Log($"[IRCBridge] Connection result: {result}");
            return result;
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Connection failed: {ex.Message}");
            JsLastError = ex.Message;
            return false;
        }
    }
    
    /// <summary>
    /// Connect to IRC with custom configuration
    /// </summary>
    public async UniTask<bool> JsConnectWithConfigAsync(string nickname, string channel = null)
    {
        if (_ircService == null)
        {
            Debug.LogError("[IRCBridge] IRCService not available");
            return false;
        }
        
        try
        {
            // Update nickname before connecting
            JsSetNickname(nickname);
            
            // Connect
            var connected = await JsConnectAsync();
            
            // Join channel if specified
            if (connected && !string.IsNullOrEmpty(channel))
            {
                await UniTask.Delay(500); // Brief delay to ensure connection is stable
                JsJoinChannel(channel);
            }
            
            return connected;
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Connection with config failed: {ex.Message}");
            JsLastError = ex.Message;
            return false;
        }
    }
    
    /// <summary>
    /// Disconnect from IRC server
    /// </summary>
    public void JsDisconnect()
    {
        if (_ircService != null)
        {
            _ircService.Disconnect();
            Debug.Log("[IRCBridge] Disconnected from IRC");
        }
    }
    
    /// <summary>
    /// Check if connected to IRC
    /// </summary>
    public bool JsIsConnectedToIRC()
    {
        return _ircService?.IsConnectedValue ?? false;
    }
    
    #endregion
    
    #region OneJS Public Methods - Messaging
    
    /// <summary>
    /// Send a message to the current channel
    /// </summary>
    public void JsSendMessage(string message)
    {
        if (_ircService != null && !string.IsNullOrEmpty(JsCurrentChannel))
        {
            _ircService.SendMessage(JsCurrentChannel, message);
            Debug.Log($"[IRCBridge] Sent message to {JsCurrentChannel}: {message}");
        }
        else
        {
            Debug.LogWarning("[IRCBridge] Cannot send message - no channel joined");
        }
    }
    
    /// <summary>
    /// Send a message to a specific channel
    /// </summary>
    public void JsSendMessageToChannel(string channel, string message)
    {
        if (_ircService != null)
        {
            _ircService.SendMessage(channel, message);
            Debug.Log($"[IRCBridge] Sent message to {channel}: {message}");
        }
    }
    
    /// <summary>
    /// Send a private message to a user
    /// </summary>
    public void JsSendPrivateMessage(string nickname, string message)
    {
        if (_ircService != null)
        {
            _ircService.SendMessage(nickname, message);
            Debug.Log($"[IRCBridge] Sent private message to {nickname}: {message}");
        }
    }
    
    /// <summary>
    /// Send a raw IRC command
    /// </summary>
    public void JsSendRawCommand(string command)
    {
        if (_ircService != null)
        {
            _ircService.SendRawCommand(command);
            Debug.Log($"[IRCBridge] Sent raw command: {command}");
        }
    }
    
    #endregion
    
    #region OneJS Public Methods - Channel Management
    
    /// <summary>
    /// Join an IRC channel
    /// </summary>
    public void JsJoinChannel(string channel)
    {
        if (_ircService != null)
        {
            _ircService.JoinChannel(channel);
            Debug.Log($"[IRCBridge] Joining channel: {channel}");
        }
    }
    
    /// <summary>
    /// Leave an IRC channel
    /// </summary>
    public void JsLeaveChannel(string channel)
    {
        if (_ircService != null)
        {
            _ircService.LeaveChannel(channel);
            Debug.Log($"[IRCBridge] Leaving channel: {channel}");
        }
    }
    
    /// <summary>
    /// Leave the current channel
    /// </summary>
    public void JsLeaveCurrentChannel()
    {
        if (_ircService != null && !string.IsNullOrEmpty(JsCurrentChannel))
        {
            _ircService.LeaveChannel(JsCurrentChannel);
            Debug.Log($"[IRCBridge] Left channel: {JsCurrentChannel}");
        }
    }
    
    #endregion
    
    #region OneJS Public Methods - User Management
    
    /// <summary>
    /// Set nickname (must be done before connecting)
    /// </summary>
    public void JsSetNickname(string nickname)
    {
        // This would need to be implemented in IRCService
        // For now, just update the local tracking
        Debug.Log($"[IRCBridge] Setting nickname: {nickname}");
        // You'd need to add this functionality to IRCService
    }
    
    /// <summary>
    /// Get the current nickname
    /// </summary>
    public string JsGetNickname()
    {
        return JsCurrentNickname;
    }
    
    #endregion
    
    #region OneJS Public Methods - Message History
    
    /// <summary>
    /// Get recent messages as an array
    /// </summary>
    public string[] JsGetRecentMessages(int count = 10)
    {
        if (_jsRecentMessages == null || _jsRecentMessages.Count == 0)
            return new string[0];
        
        var messages = _jsRecentMessages.TakeLast(Math.Min(count, _jsRecentMessages.Count));
        return messages.ToArray();
    }
    
    /// <summary>
    /// Clear message history
    /// </summary>
    public void JsClearMessageHistory()
    {
        _jsRecentMessages = new List<string>();
        JsRecentMessages = _jsRecentMessages;
        Debug.Log("[IRCBridge] Message history cleared");
    }
    
    /// <summary>
    /// Get the number of pending messages
    /// </summary>
    public int JsGetPendingMessageCount()
    {
        return JsPendingMessages;
    }
    
    #endregion
    
    #region OneJS Public Methods - Utility
    
    /// <summary>
    /// Get connection status string
    /// </summary>
    public string JsGetConnectionStatus()
    {
        if (_ircService == null)
            return "Service Unavailable";
        
        return JsConnectionState;
    }
    
    /// <summary>
    /// Get a formatted summary of the current IRC state
    /// </summary>
    public string JsGetIRCSummary()
    {
        if (_ircService == null)
            return "IRC Service not available";
        
        if (!JsIsConnected)
            return "Disconnected from IRC";
        
        return $"Connected as {JsCurrentNickname} in {JsCurrentChannel}";
    }
    
    /// <summary>
    /// Check if the service is available
    /// </summary>
    public bool JsIsServiceAvailable()
    {
        return _ircService != null;
    }
    
    /// <summary>
    /// Get the last error message
    /// </summary>
    public string JsGetLastError()
    {
        return JsLastError;
    }
    
    /// <summary>
    /// Set the maximum number of messages to keep in history
    /// </summary>
    public void JsSetMaxMessageHistory(int max)
    {
        maxRecentMessages = Math.Max(1, Math.Min(1000, max)); // Clamp between 1 and 1000
        
        // Trim existing messages if needed
        while (_jsRecentMessages != null && _jsRecentMessages.Count > maxRecentMessages)
        {
            _jsRecentMessages.RemoveAt(0);
        }
        
        Debug.Log($"[IRCBridge] Max message history set to: {maxRecentMessages}");
    }
    
    #endregion
}