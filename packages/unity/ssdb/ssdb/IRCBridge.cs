using System;
using UnityEngine;
using OneJS;
using R3;
using VContainer;
using VContainer.Unity;
using KBVE.SSDB.IRC;
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
using KBVE.SSDB.Steam;
#endif
using Cysharp.Threading.Tasks;
using System.Threading;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// OneJS Bridge for IRC service
/// This class should be attached to a GameObject in the scene for OneJS to reference
/// It syncs with the VContainer-injected IRCService instance
/// Uses simpler namespace for OneJS Source Generator compatibility
/// </summary>
public partial class IRCBridge : MonoBehaviour
{
    private IIRCService _ircService;
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
    private SteamUserProfiles _steamUserProfiles;
#endif
    private readonly CompositeDisposable _disposables = new();
    
    #region OneJS EventfulProperty Fields
    
    // EventfulProperty fields for OneJS bidirectional binding
    // OneJS Source Generator will auto-create properties and events
    [EventfulProperty] bool _jsIsConnected = false;
    [EventfulProperty] string _jsConnectionState = "Disconnected";
    [EventfulProperty] string _jsCurrentChannel = string.Empty;
    [EventfulProperty] string _jsCurrentNickname = string.Empty;
    [EventfulProperty] string _jsSteamUsername = string.Empty;
    [EventfulProperty] bool _jsSteamReady = false;
    [EventfulProperty] int _jsPendingMessages = 0;
    [EventfulProperty] string _jsLastMessage = string.Empty;
    [EventfulProperty] string _jsLastError = string.Empty;
    [EventfulProperty] string _jsLastRawMessage = string.Empty;
    [EventfulProperty] int _jsMessageCount = 0;
    [EventfulProperty] List<string> _jsChannelUsers = new();
    
    // Auto-generated by EventfulProperty:
    // - public bool JsIsConnected { get; set; }
    // - public event Action<bool> OnJsIsConnectedChanged;
    // - etc. for all fields above
    
    #endregion

    #region Configuration
    
    // Configuration that can be set from Unity Inspector or OneJS
    [Header("IRC Configuration")]
    [SerializeField] private string server = "irc.kbve.com";
    [SerializeField] private int port = 6697;
    [SerializeField] private bool useSsl = true;
    [SerializeField] private string defaultChannel = "#general";
    [SerializeField] private bool autoConnect = false;
    
    #endregion

    #region Unity Lifecycle
    
    private void Start()
    {
        // Find the IRCService instance from VContainer using UniTask
        InitializeIRCConnection().Forget();
    }
    
    private void OnDestroy()
    {
        _disposables.Dispose();
    }
    
    #endregion
    
    #region Initialization
    
    private async UniTaskVoid InitializeIRCConnection()
    {
        try
        {
            // Use UniTask for non-blocking async initialization
            await WaitForIRCServiceAsync();
        }
        catch (OperationCanceledException)
        {
            Debug.LogWarning("[IRCBridge] IRC connection initialization was cancelled or timed out");
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Failed to initialize IRC connection: {ex.Message}");
        }
    }
    
    private async UniTask WaitForIRCServiceAsync()
    {
        var destroyCancellationToken = this.GetCancellationTokenOnDestroy();
        
        try
        {
            Debug.Log("[IRCBridge] Starting async search for services...");
            
            // Use UniTask.WaitUntil for finding services with timeout
            var findServicesTask = FindServicesAsync(destroyCancellationToken);
            var timeoutTask = UniTask.Delay(TimeSpan.FromSeconds(30), cancellationToken: destroyCancellationToken);
            
            var completedTaskIndex = await UniTask.WhenAny(findServicesTask, timeoutTask);
            
            if (completedTaskIndex == 1) // Timeout
            {
                Debug.LogWarning("[IRCBridge] Timeout finding services");
                return;
            }
            
            // Services found, wait for Steam to be ready and then initialize
            if (_ircService != null)
            {
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
                if (_steamUserProfiles != null)
                {
                    await WaitForSteamReadyAsync(destroyCancellationToken);
                }
#endif
                
                InitializeBindings();
                
                // Auto-connect if configured (Steam username is already set in IRCService)
                if (autoConnect)
                {
                    await JsConnectAsync();
                }
            }
        }
        catch (OperationCanceledException)
        {
            Debug.Log("[IRCBridge] Service search cancelled");
        }
    }
    
    private async UniTask FindServicesAsync(CancellationToken cancellationToken)
    {
        await UniTask.WaitUntil(() =>
        {
            try
            {
                var lifetimeScope = FindAnyObjectByType<LifetimeScope>();
                if (lifetimeScope?.Container != null)
                {
                    // Find IRCService
                    if (_ircService == null && lifetimeScope.Container.TryResolve<IIRCService>(out var ircService))
                    {
                        _ircService = ircService;
                        Debug.Log("[IRCBridge] Found IRCService through VContainer");
                    }
                    
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
                    // Find SteamUserProfiles (optional)
                    if (_steamUserProfiles == null && lifetimeScope.Container.TryResolve<SteamUserProfiles>(out var steamProfiles))
                    {
                        _steamUserProfiles = steamProfiles;
                        Debug.Log("[IRCBridge] Found SteamUserProfiles through VContainer");
                    }
#endif
                    
                    // Return true when we have at least IRCService
                    return _ircService != null;
                }
                return false;
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[IRCBridge] Error in service search: {ex.Message}");
                return false;
            }
        }, cancellationToken: cancellationToken);
    }
    
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
    private async UniTask WaitForSteamReadyAsync(CancellationToken cancellationToken)
    {
        if (_steamUserProfiles == null) return;
        
        Debug.Log("[IRCBridge] Waiting for Steam to be ready...");
        
        try
        {
            // Use UniTask.WaitUntil with timeout for better async handling
            var steamReadyTask = UniTask.WaitUntil(
                () => !string.IsNullOrEmpty(_steamUserProfiles?.UserName.Value),
                cancellationToken: cancellationToken
            );
            
            var timeoutTask = UniTask.Delay(TimeSpan.FromSeconds(15), cancellationToken: cancellationToken);
            
            var completedTaskIndex = await UniTask.WhenAny(steamReadyTask, timeoutTask);
            
            if (completedTaskIndex == 0) // Steam ready
            {
                JsSteamUsername = _steamUserProfiles.UserName.Value;
                JsSteamReady = true;
                Debug.Log($"[IRCBridge] Steam ready! Username: {JsSteamUsername}");
            }
            else
            {
                Debug.Log("[IRCBridge] Steam username not ready, proceeding without it");
                JsSteamReady = false;
            }
        }
        catch (OperationCanceledException)
        {
            Debug.Log("[IRCBridge] Steam wait cancelled");
            JsSteamReady = false;
        }
    }
#endif
    
    #endregion
    
    #region Data Binding
    
    private void InitializeBindings()
    {
        if (_ircService == null) return;
        
        Debug.Log("[IRCBridge] Initializing OneJS bindings with IRCService");
        
        // Subscribe to all reactive properties from IRCService
        _ircService.IsConnected.Subscribe(value => 
        {
            JsIsConnected = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _ircService.CurrentChannel.Subscribe(value => 
        {
            JsCurrentChannel = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _ircService.CurrentNickname.Subscribe(value => 
        {
            JsCurrentNickname = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _ircService.PendingMessages.Subscribe(value => 
        {
            JsPendingMessages = value; // Auto-generated property
        }).AddTo(_disposables);
        
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
        // Subscribe to Steam username changes (if Steam integration is available)
        if (_steamUserProfiles != null)
        {
            _steamUserProfiles.UserName.Subscribe(value => 
            {
                JsSteamUsername = value; // Auto-generated property
                JsSteamReady = !string.IsNullOrEmpty(value);
            }).AddTo(_disposables);
        }
#endif
        
        // Subscribe to connection state changes
        _ircService.OnConnectionStateChanged.Subscribe(state => 
        {
            JsConnectionState = state.ToString(); // Auto-generated property
        }).AddTo(_disposables);
        
        // Subscribe to messages for reactive updates
        _ircService.OnMessageReceived.Subscribe(message => 
        {
            // Update reactive properties for OneJS
            JsLastMessage = FormatMessage(message);
            JsMessageCount = _ircService.GetMessageCount();
        }).AddTo(_disposables);
        
        // Subscribe to errors
        _ircService.OnError.Subscribe(error => 
        {
            JsLastError = error; // Auto-generated property
            Debug.LogWarning($"[IRCBridge] IRC Error: {error}");
        }).AddTo(_disposables);
        
        // Subscribe to raw messages (optional, for debugging)
        _ircService.OnRawMessageReceived.Subscribe(raw => 
        {
            JsLastRawMessage = raw; // Auto-generated property
        }).AddTo(_disposables);
    }
    
    
    private string FormatMessage(IRCMessage message)
    {
        if (message.isChannelMessage || message.isPrivateMessage)
        {
            return $"[{message.timestamp:HH:mm:ss}] <{message.nickname}> {message.message}";
        }
        else if (message.isServerMessage)
        {
            return $"[{message.timestamp:HH:mm:ss}] * {message.message}";
        }
        else
        {
            return $"[{message.timestamp:HH:mm:ss}] {message.rawMessage}";
        }
    }
    
    private void UpdateChannelUsers()
    {
        // This would need to be implemented based on your IRC protocol handling
        // For now, just trigger an update event
        JsChannelUsers = new List<string>(_jsChannelUsers ?? new List<string>());
    }
    
    #endregion
    
    #region OneJS Public Methods - Connection Management
    
    /// <summary>
    /// Connect to IRC server asynchronously
    /// </summary>
    public async UniTask<bool> JsConnectAsync()
    {
        if (_ircService == null)
        {
            Debug.LogError("[IRCBridge] IRCService not available");
            return false;
        }
        
        try
        {
            Debug.Log($"[IRCBridge] Connecting to IRC server...");
            var result = await _ircService.ConnectAsync(this.GetCancellationTokenOnDestroy());
            Debug.Log($"[IRCBridge] Connection result: {result}");
            return result;
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Connection failed: {ex.Message}");
            JsLastError = ex.Message;
            return false;
        }
    }
    
    /// <summary>
    /// Connect to IRC with custom configuration
    /// </summary>
    public async UniTask<bool> JsConnectWithConfigAsync(string nickname, string channel = null)
    {
        if (_ircService == null)
        {
            Debug.LogError("[IRCBridge] IRCService not available");
            return false;
        }
        
        try
        {
            // Update nickname before connecting
            JsSetNickname(nickname);
            
            // Connect
            var connected = await JsConnectAsync();
            
            // Join channel if specified
            if (connected && !string.IsNullOrEmpty(channel))
            {
                await UniTask.Delay(500); // Brief delay to ensure connection is stable
                JsJoinChannel(channel);
            }
            
            return connected;
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Connection with config failed: {ex.Message}");
            JsLastError = ex.Message;
            return false;
        }
    }
    
    /// <summary>
    /// Disconnect from IRC server
    /// </summary>
    public void JsDisconnect()
    {
        if (_ircService != null)
        {
            _ircService.Disconnect();
            Debug.Log("[IRCBridge] Disconnected from IRC");
        }
    }
    
    /// <summary>
    /// Reconnect to IRC server (disconnect then connect)
    /// </summary>
    public async UniTask<bool> JsReconnectAsync()
    {
        if (_ircService == null)
        {
            Debug.LogError("[IRCBridge] IRCService not available for reconnection");
            return false;
        }
        
        try
        {
            Debug.Log("[IRCBridge] Starting reconnection process...");
            
            // First disconnect if currently connected
            if (JsIsConnected)
            {
                Debug.Log("[IRCBridge] Disconnecting before reconnection...");
                JsDisconnect();
                
                // Wait a moment for disconnect to complete
                await UniTask.Delay(1000, cancellationToken: this.GetCancellationTokenOnDestroy());
            }
            
            // Now attempt to connect
            Debug.Log("[IRCBridge] Attempting to reconnect...");
            var result = await JsConnectAsync();
            
            if (result)
            {
                Debug.Log("[IRCBridge] Reconnection successful");
            }
            else
            {
                Debug.LogWarning("[IRCBridge] Reconnection failed");
            }
            
            return result;
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Reconnection error: {ex.Message}");
            JsLastError = ex.Message;
            return false;
        }
    }
    
    /// <summary>
    /// Check if connected to IRC
    /// </summary>
    public bool JsIsConnectedToIRC()
    {
        return _ircService?.IsConnectedValue ?? false;
    }
    
    #endregion
    
    #region OneJS Public Methods - Messaging
    
    /// <summary>
    /// Send a message to the current channel
    /// </summary>
    public void JsSendMessage(string message)
    {
        if (_ircService != null && !string.IsNullOrEmpty(JsCurrentChannel))
        {
            _ircService.SendMessage(JsCurrentChannel, message);
            Debug.Log($"[IRCBridge] Sent message to {JsCurrentChannel}: {message}");
        }
        else
        {
            Debug.LogWarning("[IRCBridge] Cannot send message - no channel joined");
        }
    }
    
    /// <summary>
    /// Send a message to a specific channel
    /// </summary>
    public void JsSendMessageToChannel(string channel, string message)
    {
        if (_ircService != null)
        {
            _ircService.SendMessage(channel, message);
            Debug.Log($"[IRCBridge] Sent message to {channel}: {message}");
        }
    }
    
    /// <summary>
    /// Send a private message to a user
    /// </summary>
    public void JsSendPrivateMessage(string nickname, string message)
    {
        if (_ircService != null)
        {
            _ircService.SendMessage(nickname, message);
            Debug.Log($"[IRCBridge] Sent private message to {nickname}: {message}");
        }
    }
    
    /// <summary>
    /// Send a raw IRC command
    /// </summary>
    public void JsSendRawCommand(string command)
    {
        if (_ircService != null)
        {
            _ircService.SendRawCommand(command);
            Debug.Log($"[IRCBridge] Sent raw command: {command}");
        }
    }
    
    #endregion
    
    #region OneJS Public Methods - Channel Management
    
    /// <summary>
    /// Join an IRC channel
    /// </summary>
    public void JsJoinChannel(string channel)
    {
        if (_ircService != null)
        {
            _ircService.JoinChannel(channel);
            Debug.Log($"[IRCBridge] Joining channel: {channel}");
        }
    }
    
    /// <summary>
    /// Leave an IRC channel
    /// </summary>
    public void JsLeaveChannel(string channel)
    {
        if (_ircService != null)
        {
            _ircService.LeaveChannel(channel);
            Debug.Log($"[IRCBridge] Leaving channel: {channel}");
        }
    }
    
    /// <summary>
    /// Leave the current channel
    /// </summary>
    public void JsLeaveCurrentChannel()
    {
        if (_ircService != null && !string.IsNullOrEmpty(JsCurrentChannel))
        {
            _ircService.LeaveChannel(JsCurrentChannel);
            Debug.Log($"[IRCBridge] Left channel: {JsCurrentChannel}");
        }
    }
    
    #endregion
    
    #region OneJS Public Methods - User Management
    
    /// <summary>
    /// Set nickname (must be done before connecting)
    /// </summary>
    public void JsSetNickname(string nickname)
    {
        // This would need to be implemented in IRCService
        // For now, just update the local tracking
        Debug.Log($"[IRCBridge] Setting nickname: {nickname}");
        // You'd need to add this functionality to IRCService
    }
    
    /// <summary>
    /// Get the current nickname
    /// </summary>
    public string JsGetNickname()
    {
        return JsCurrentNickname;
    }
    
    #endregion
    
    #region OneJS Public Methods - Message History
    
    /// <summary>
    /// Get recent messages directly from IRCService
    /// </summary>
    public string[] JsGetRecentMessages(int count = 50)
    {
        if (_ircService == null)
            return new string[0];
        
        var messages = _ircService.GetRecentMessages(count);
        var formattedMessages = new string[messages.Length];
        
        for (int i = 0; i < messages.Length; i++)
        {
            formattedMessages[i] = FormatMessage(messages[i]);
        }
        
        return formattedMessages;
    }
    
    /// <summary>
    /// Get recent messages as IRCMessage objects for advanced processing
    /// </summary>
    public IRCMessage[] JsGetRecentMessagesRaw(int count = 50)
    {
        if (_ircService == null)
            return new IRCMessage[0];
        
        return _ircService.GetRecentMessages(count);
    }
    
    /// <summary>
    /// Get total message count from IRCService
    /// </summary>
    public int JsGetTotalMessageCount()
    {
        return _ircService?.GetMessageCount() ?? 0;
    }
    
    /// <summary>
    /// Get the latest message
    /// </summary>
    public string JsGetLatestMessage()
    {
        if (_ircService == null)
            return string.Empty;
        
        var latestMessage = _ircService.GetLatestMessage();
        return latestMessage != null ? FormatMessage(latestMessage) : string.Empty;
    }
    
    /// <summary>
    /// Get the latest message as raw IRCMessage object
    /// </summary>
    public IRCMessage JsGetLatestMessageRaw()
    {
        return _ircService?.GetLatestMessage();
    }
    
    /// <summary>
    /// Get messages filtered by type (channel, private, server)
    /// </summary>
    public string[] JsGetMessagesByType(string messageType, int count = 50)
    {
        if (_ircService == null)
            return new string[0];
        
        var allMessages = _ircService.GetRecentMessages(count);
        var filteredMessages = new List<string>();
        
        foreach (var message in allMessages)
        {
            bool includeMessage = messageType.ToLower() switch
            {
                "channel" => message.isChannelMessage,
                "private" => message.isPrivateMessage,
                "server" => message.isServerMessage,
                "all" => true,
                _ => true
            };
            
            if (includeMessage)
            {
                filteredMessages.Add(FormatMessage(message));
            }
        }
        
        return filteredMessages.ToArray();
    }
    
    /// <summary>
    /// Get messages from a specific channel
    /// </summary>
    public string[] JsGetChannelMessages(string channel, int count = 50)
    {
        if (_ircService == null || string.IsNullOrEmpty(channel))
            return new string[0];
        
        var allMessages = _ircService.GetRecentMessages(count * 2); // Get more to filter
        var channelMessages = new List<string>();
        
        foreach (var message in allMessages)
        {
            if (message.isChannelMessage && 
                string.Equals(message.channel, channel, StringComparison.OrdinalIgnoreCase))
            {
                channelMessages.Add(FormatMessage(message));
                
                if (channelMessages.Count >= count)
                    break;
            }
        }
        
        return channelMessages.ToArray();
    }
    
    /// <summary>
    /// Get the number of pending messages (unprocessed)
    /// </summary>
    public int JsGetPendingMessageCount()
    {
        return JsPendingMessages;
    }
    
    #endregion
    
    #region OneJS Public Methods - Utility
    
    /// <summary>
    /// Get connection status string
    /// </summary>
    public string JsGetConnectionStatus()
    {
        if (_ircService == null)
            return "Service Unavailable";
        
        return JsConnectionState;
    }
    
    /// <summary>
    /// Get a formatted summary of the current IRC state
    /// </summary>
    public string JsGetIRCSummary()
    {
        if (_ircService == null)
            return "IRC Service not available";
        
        if (!JsIsConnected)
            return "Disconnected from IRC";
        
        return $"Connected as {JsCurrentNickname} in {JsCurrentChannel}";
    }
    
    /// <summary>
    /// Check if the service is available
    /// </summary>
    public bool JsIsServiceAvailable()
    {
        return _ircService != null;
    }
    
    /// <summary>
    /// Get the last error message
    /// </summary>
    public string JsGetLastError()
    {
        return JsLastError;
    }
    
    /// <summary>
    /// Get statistics about the message buffer
    /// </summary>
    public string JsGetMessageStats()
    {
        if (_ircService == null)
            return "IRC Service not available";
        
        var totalMessages = _ircService.GetMessageCount();
        var pendingMessages = JsPendingMessages;
        
        return $"Messages: {totalMessages} total, {pendingMessages} pending";
    }
    
    #endregion
    
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
    #region OneJS Public Methods - Steam Integration
    
    /// <summary>
    /// Get username from Steam ID (with caching)
    /// Accepts formats: "S76561198123456789" or "76561198123456789"
    /// </summary>
    /// <param name="steamId">The Steam ID with or without 'S' prefix</param>
    /// <returns>A promise that resolves to the username or null</returns>
    public async UniTask<string> JsUsernameFromSteamID(string steamId)
    {
        if (_steamUserProfiles == null)
        {
            Debug.LogWarning("[IRCBridge] Steam integration not available");
            return null;
        }
        
        if (string.IsNullOrEmpty(steamId))
        {
            Debug.LogWarning("[IRCBridge] Empty Steam ID provided");
            return null;
        }
        
        try
        {
            Debug.Log($"[IRCBridge] Looking up username for Steam ID: {steamId}");
            
            // Use the cached lookup from SteamUserProfiles
            var username = await _steamUserProfiles.GetUsernameFromSteamIdAsync(
                steamId, 
                this.GetCancellationTokenOnDestroy()
            );
            
            if (!string.IsNullOrEmpty(username))
            {
                Debug.Log($"[IRCBridge] Found username for {steamId}: {username}");
            }
            else
            {
                Debug.Log($"[IRCBridge] Could not find username for {steamId}");
            }
            
            return username;
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Error looking up Steam ID {steamId}: {ex.Message}");
            return null;
        }
    }
    
    /// <summary>
    /// Batch lookup of usernames from Steam IDs
    /// </summary>
    /// <param name="steamIds">Array of Steam IDs</param>
    /// <returns>Dictionary mapping Steam IDs to usernames</returns>
    public async UniTask<Dictionary<string, string>> JsBatchUsernamesFromSteamIDs(string[] steamIds)
    {
        var results = new Dictionary<string, string>();
        
        if (_steamUserProfiles == null || steamIds == null || steamIds.Length == 0)
        {
            return results;
        }
        
        // Process in parallel but limit concurrency to avoid overwhelming Steam API
        const int maxConcurrency = 5;
        var semaphore = new SemaphoreSlim(maxConcurrency);
        var tasks = new List<UniTask>();
        
        foreach (var steamId in steamIds)
        {
            if (string.IsNullOrEmpty(steamId)) continue;
            
            tasks.Add(ProcessSteamIdAsync(steamId, results, semaphore));
        }
        
        await UniTask.WhenAll(tasks);
        
        return results;
    }
    
    private async UniTask ProcessSteamIdAsync(string steamId, Dictionary<string, string> results, SemaphoreSlim semaphore)
    {
        await semaphore.WaitAsync();
        try
        {
            var username = await JsUsernameFromSteamID(steamId);
            if (!string.IsNullOrEmpty(username))
            {
                lock (results)
                {
                    results[steamId] = username;
                }
            }
        }
        finally
        {
            semaphore.Release();
        }
    }
    
    /// <summary>
    /// Clear the Steam username cache
    /// </summary>
    public void JsClearSteamUsernameCache()
    {
        if (_steamUserProfiles != null)
        {
            _steamUserProfiles.ClearUsernameCache();
            Debug.Log("[IRCBridge] Steam username cache cleared");
        }
    }
    
    /// <summary>
    /// Get Steam cache statistics for debugging
    /// </summary>
    public string JsGetSteamCacheStats()
    {
        if (_steamUserProfiles == null)
            return "Steam integration not available";
        
        var stats = _steamUserProfiles.GetCacheStats();
        return $"Cache: {stats.totalEntries} total, {stats.validEntries} valid, {stats.expiredEntries} expired";
    }
    
    /// <summary>
    /// Check if Steam integration is available
    /// </summary>
    public bool JsIsSteamAvailable()
    {
        return _steamUserProfiles != null && JsSteamReady;
    }
    
    /// <summary>
    /// Format an IRC message with Steam username lookup
    /// </summary>
    public async UniTask<string> JsFormatMessageWithSteamName(IRCMessage message)
    {
        if (message == null) return string.Empty;
        
        // Check if nickname is a Steam ID (starts with 'S' followed by numbers)
        if (!string.IsNullOrEmpty(message.nickname) && 
            message.nickname.StartsWith("S") && 
            message.nickname.Length > 1 &&
            message.nickname[1..].All(char.IsDigit))
        {
            var username = await JsUsernameFromSteamID(message.nickname);
            if (!string.IsNullOrEmpty(username))
            {
                return $"[{message.timestamp:HH:mm:ss}] <{username}> {message.message}";
            }
        }
        
        // Fallback to regular formatting
        return FormatMessage(message);
    }
    
    #endregion
#endif
}