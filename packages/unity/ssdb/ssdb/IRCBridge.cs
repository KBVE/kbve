using System;
using UnityEngine;
using OneJS;
using R3;
using ObservableCollections;
using VContainer;
using VContainer.Unity;
using KBVE.SSDB.IRC;
using KBVE.SSDB;
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
using KBVE.SSDB.Steam;
#endif
using Cysharp.Threading.Tasks;
using System.Threading;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// OneJS Bridge for IRC service
/// This class should be attached to a GameObject in the scene for OneJS to reference
/// It syncs with the VContainer-injected IRCService instance
/// Uses simpler namespace for OneJS Source Generator compatibility
/// </summary>
public partial class IRCBridge : MonoBehaviour, IInitializable
{
    [Inject]
    private IIRCService _ircService;
    
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
    [Inject]
    private SteamUserProfiles _steamUserProfiles;
#endif

    [Inject]
    private IObjectResolver _container;
    
    private readonly CompositeDisposable _disposables = new();

    [Header("Debug Settings")]
    [SerializeField] private bool enableDiagnostics = false;

    /// <summary>
    /// Helper method to log diagnostic messages only when diagnostics are enabled
    /// </summary>
    private void LogDiagnostic(string message)
    {
        if (enableDiagnostics)
        {
            Debug.Log($"[IRCBridge] {message}");
        }
    }

    #region OneJS EventfulProperty Fields
    
    // EventfulProperty fields for OneJS bidirectional binding
    // OneJS Source Generator will auto-create properties and events
    [EventfulProperty] bool _jsIsConnected = false;
    [EventfulProperty] string _jsConnectionState = "Disconnected";
    [EventfulProperty] string _jsCurrentChannel = string.Empty;
    [EventfulProperty] string _jsCurrentNickname = string.Empty;
    [EventfulProperty] string _jsSteamUsername = string.Empty;
    [EventfulProperty] bool _jsSteamReady = false;
    [EventfulProperty] int _jsPendingMessages = 0;
    [EventfulProperty] string _jsLastMessage = string.Empty;
    [EventfulProperty] string _jsLastError = string.Empty;
    [EventfulProperty] string _jsLastRawMessage = string.Empty;
    [EventfulProperty] int _jsMessageCount = 0;
    [EventfulProperty] List<string> _jsChannelUsers = new();
    [EventfulProperty] List<string> _jsMessagesList = new(); // Simple List<string> for better JS binding
    [EventfulProperty] IRCMessage _jsLatestMessage = null; // Latest message for incremental updates
    
    // Auto-generated by EventfulProperty:
    // - public bool JsIsConnected { get; set; }
    // - public event Action<bool> OnJsIsConnectedChanged;
    // - etc. for all fields above
    
    #endregion

    #region Configuration
    
    // Configuration that can be set from Unity Inspector or OneJS
    [Header("IRC Configuration")]
    [SerializeField] private string server = "irc.kbve.com";
    [SerializeField] private int port = 6697;
    [SerializeField] private bool useSsl = true;
    [SerializeField] private string defaultChannel = "#general";
    [SerializeField] private bool autoConnect = false;
    [SerializeField] private int maxMessages = 500; // Maximum messages to keep in memory
    
    #endregion

    #region VContainer Lifecycle
    
    public void Initialize()
    {
        LogDiagnostic("VContainer Initialize() called");

        // Run diagnostics first to understand the container state (only if enabled)
        if (enableDiagnostics)
        {
            DiagnoseContainerState();
        }
        
        // Try to resolve services through injected container if injection didn't work
        if (_ircService == null && _container != null)
        {
            Debug.Log("[IRCBridge] Attempting to resolve IIRCService through injected container");
            if (_container.TryResolve<IIRCService>(out var ircService))
            {
                _ircService = ircService;
                Debug.Log("[IRCBridge] ✓ Successfully resolved IIRCService through injected container");
            }
            else
            {
                Debug.LogWarning("[IRCBridge] ✗ Failed to resolve IIRCService through injected container");
            }
        }
        
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
        if (_steamUserProfiles == null && _container != null)
        {
            Debug.Log("[IRCBridge] Attempting to resolve SteamUserProfiles through injected container");
            if (_container.TryResolve<SteamUserProfiles>(out var steamProfiles))
            {
                _steamUserProfiles = steamProfiles;
                Debug.Log("[IRCBridge] ✓ Successfully resolved SteamUserProfiles through injected container");
            }
            else
            {
                Debug.LogWarning("[IRCBridge] ✗ Failed to resolve SteamUserProfiles through injected container");
            }
        }
#endif
        
        if (_ircService != null)
        {
            Debug.Log("[IRCBridge] IRC Service available, initializing with injected service");
            InitializeWithInjectedService().Forget();
        }
        else
        {
            Debug.LogWarning("[IRCBridge] IRC Service not available after VContainer initialization, will fall back to manual search");
        }
    }
    
    #endregion

    #region Unity Lifecycle
    
    private void Start()
    {
        // Fallback if VContainer initialization didn't work
        if (_ircService == null)
        {
            Debug.LogWarning("[IRCBridge] IRCService not available, attempting manual search");
            InitializeIRCConnection().Forget();
        }
    }
    
    private async UniTaskVoid InitializeWithInjectedService()
    {
        try
        {
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
            if (_steamUserProfiles != null)
            {
                await WaitForSteamReadyAsync(this.GetCancellationTokenOnDestroy());
            }
#endif
            
            InitializeBindings();
            
            // Auto-connect if configured
            if (autoConnect)
            {
                await JsConnectAsync();
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Initialization error: {ex.Message}");
        }
    }
    
    private void OnDestroy()
    {
        _disposables.Dispose();
    }
    
    #endregion
    
    #region Initialization
    
    private async UniTaskVoid InitializeIRCConnection()
    {
        try
        {
            // Use UniTask for non-blocking async initialization
            await WaitForIRCServiceAsync();
        }
        catch (OperationCanceledException)
        {
            Debug.LogWarning("[IRCBridge] IRC connection initialization was cancelled or timed out");
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Failed to initialize IRC connection: {ex.Message}");
        }
    }
    
    private async UniTask WaitForIRCServiceAsync()
    {
        var destroyCancellationToken = this.GetCancellationTokenOnDestroy();
        
        try
        {
            Debug.Log("[IRCBridge] Starting async search for services...");
            
            // Run diagnostics to help troubleshoot container issues
            DiagnoseContainerState();
            
            // Use UniTask.WaitUntil for finding services with timeout
            var findServicesTask = FindServicesAsync(destroyCancellationToken);
            var timeoutTask = UniTask.Delay(TimeSpan.FromSeconds(60), cancellationToken: destroyCancellationToken);
            
            var completedTaskIndex = await UniTask.WhenAny(findServicesTask, timeoutTask);
            
            if (completedTaskIndex == 1) // Timeout
            {
                Debug.LogWarning("[IRCBridge] Timeout finding services");
                return;
            }
            
            // Services found, wait for Steam to be ready and then initialize
            if (_ircService != null)
            {
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
                if (_steamUserProfiles != null)
                {
                    await WaitForSteamReadyAsync(destroyCancellationToken);
                }
#endif
                
                InitializeBindings();
                
                // Auto-connect if configured (Steam username is already set in IRCService)
                if (autoConnect)
                {
                    await JsConnectAsync();
                }
            }
        }
        catch (OperationCanceledException)
        {
            Debug.Log("[IRCBridge] Service search cancelled");
        }
    }
    
    private async UniTask FindServicesAsync(CancellationToken cancellationToken)
    {
        await UniTask.WaitUntil(() =>
        {
            try
            {
                // First try to use injected container if available
                if (_container != null)
                {
                    Debug.Log("[IRCBridge] Using injected container for service resolution");
                    
                    // Try to resolve IRCService using the injected container
                    if (_ircService == null && _container.TryResolve<IIRCService>(out var ircService))
                    {
                        _ircService = ircService;
                        Debug.Log("[IRCBridge] Found IRCService through injected container");
                    }
                    
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
                    // Try to resolve SteamUserProfiles using the injected container
                    if (_steamUserProfiles == null && _container.TryResolve<SteamUserProfiles>(out var steamProfiles))
                    {
                        _steamUserProfiles = steamProfiles;
                        Debug.Log("[IRCBridge] Found SteamUserProfiles through injected container");
                    }
#endif
                    
                    // Return true when we have at least IRCService
                    if (_ircService != null) return true;
                }
                
                // Fallback: Find the specific SSDBLifetimeScope instead of any LifetimeScope
                var ssdbScope = FindAnyObjectByType<SSDBLifetimeScope>();
                if (ssdbScope?.Container != null)
                {
                    Debug.Log("[IRCBridge] Using SSDBLifetimeScope container for service resolution");
                    
                    // Find IRCService
                    if (_ircService == null && ssdbScope.Container.TryResolve<IIRCService>(out var ircService))
                    {
                        _ircService = ircService;
                        Debug.Log("[IRCBridge] Found IRCService through SSDBLifetimeScope");
                    }
                    
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
                    // Find SteamUserProfiles (optional)
                    if (_steamUserProfiles == null && ssdbScope.Container.TryResolve<SteamUserProfiles>(out var steamProfiles))
                    {
                        _steamUserProfiles = steamProfiles;
                        Debug.Log("[IRCBridge] Found SteamUserProfiles through SSDBLifetimeScope");
                    }
#endif
                    
                    // Return true when we have at least IRCService
                    return _ircService != null;
                }
                
                // Last resort: Search all LifetimeScopes for the one with IRC services
                var allScopes = FindObjectsByType<LifetimeScope>(FindObjectsSortMode.None);
                Debug.Log($"[IRCBridge] Searching through {allScopes.Length} LifetimeScopes for IRC services");
                
                foreach (var scope in allScopes)
                {
                    if (scope?.Container != null)
                    {
                        // Check if this container has IRC services
                        if (_ircService == null && scope.Container.TryResolve<IIRCService>(out var ircService))
                        {
                            _ircService = ircService;
                            Debug.Log($"[IRCBridge] Found IRCService in LifetimeScope: {scope.name}");
                        }
                        
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
                        if (_steamUserProfiles == null && scope.Container.TryResolve<SteamUserProfiles>(out var steamProfiles))
                        {
                            _steamUserProfiles = steamProfiles;
                            Debug.Log($"[IRCBridge] Found SteamUserProfiles in LifetimeScope: {scope.name}");
                        }
#endif
                        
                        // If we found the IRC service in this scope, we can stop searching
                        if (_ircService != null) break;
                    }
                }
                
                return _ircService != null;
            }
            catch (Exception ex)
            {
                Debug.LogWarning($"[IRCBridge] Error in service search: {ex.Message}");
                return false;
            }
        }, cancellationToken: cancellationToken);
    }
    
    /// <summary>
    /// Diagnostic method to help troubleshoot VContainer setup
    /// </summary>
    private void DiagnoseContainerState()
    {
        try
        {
            Debug.Log("[IRCBridge] === VContainer Diagnostics ===");
            
            // Check injected container
            if (_container != null)
            {
                Debug.Log("[IRCBridge] ✓ IObjectResolver was injected successfully");
                Debug.Log($"[IRCBridge] Container type: {_container.GetType().Name}");
            }
            else
            {
                Debug.LogWarning("[IRCBridge] ✗ IObjectResolver was NOT injected");
            }
            
            // Check all LifetimeScopes in scene
            var allScopes = FindObjectsByType<LifetimeScope>(FindObjectsSortMode.None);
            Debug.Log($"[IRCBridge] Found {allScopes.Length} LifetimeScopes in scene:");
            
            foreach (var scope in allScopes)
            {
                Debug.Log($"[IRCBridge]   - {scope.name} ({scope.GetType().Name})");
                if (scope.Container != null)
                {
                    var hasIRC = scope.Container.TryResolve<IIRCService>(out _);
                    var hasSteam = scope.Container.TryResolve<SteamUserProfiles>(out _);
                    Debug.Log($"[IRCBridge]     IRC Service: {(hasIRC ? "✓" : "✗")}");
                    Debug.Log($"[IRCBridge]     Steam Profiles: {(hasSteam ? "✓" : "✗")}");
                }
                else
                {
                    Debug.LogWarning($"[IRCBridge]     Container is NULL");
                }
            }
            
            // Check specifically for SSDBLifetimeScope
            var ssdbScope = FindAnyObjectByType<SSDBLifetimeScope>();
            if (ssdbScope != null)
            {
                Debug.Log($"[IRCBridge] ✓ Found SSDBLifetimeScope: {ssdbScope.name}");
                if (ssdbScope.Container != null)
                {
                    Debug.Log("[IRCBridge] ✓ SSDBLifetimeScope has active container");
                }
                else
                {
                    Debug.LogWarning("[IRCBridge] ✗ SSDBLifetimeScope container is NULL");
                }
            }
            else
            {
                Debug.LogWarning("[IRCBridge] ✗ SSDBLifetimeScope not found in scene");
            }
            
            Debug.Log("[IRCBridge] === End Diagnostics ===");
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Error during diagnostics: {ex.Message}");
        }
    }
    
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
    private async UniTask WaitForSteamReadyAsync(CancellationToken cancellationToken)
    {
        if (_steamUserProfiles == null) return;
        
        Debug.Log("[IRCBridge] Waiting for Steam to be ready...");
        
        try
        {
            // Use UniTask.WaitUntil with timeout for better async handling
            var steamReadyTask = UniTask.WaitUntil(
                () => !string.IsNullOrEmpty(_steamUserProfiles?.UserName.Value),
                cancellationToken: cancellationToken
            );
            
            var timeoutTask = UniTask.Delay(TimeSpan.FromSeconds(15), cancellationToken: cancellationToken);
            
            var completedTaskIndex = await UniTask.WhenAny(steamReadyTask, timeoutTask);
            
            if (completedTaskIndex == 0) // Steam ready
            {
                JsSteamUsername = _steamUserProfiles.UserName.Value;
                JsSteamReady = true;
                Debug.Log($"[IRCBridge] Steam ready! Username: {JsSteamUsername}");
            }
            else
            {
                Debug.Log("[IRCBridge] Steam username not ready, proceeding without it");
                JsSteamReady = false;
            }
        }
        catch (OperationCanceledException)
        {
            Debug.Log("[IRCBridge] Steam wait cancelled");
            JsSteamReady = false;
        }
    }
#endif
    
    #endregion
    
    #region Data Binding
    
    private void InitializeBindings()
    {
        if (_ircService == null) 
        {
            Debug.LogError("[IRCBridge] Cannot initialize bindings - IRCService is null!");
            return;
        }
        
        Debug.Log("[IRCBridge] ✓ Initializing OneJS bindings with IRCService");
        
        // Subscribe to all reactive properties from IRCService
        _ircService.IsConnected.Subscribe(value => 
        {
            Debug.Log($"[IRCBridge] IRC Connected state changed: {value}");
            JsIsConnected = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _ircService.CurrentChannel.Subscribe(value => 
        {
            Debug.Log($"[IRCBridge] IRC Current channel changed: {value}");
            JsCurrentChannel = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _ircService.CurrentNickname.Subscribe(value => 
        {
            Debug.Log($"[IRCBridge] IRC Current nickname changed: {value}");
            JsCurrentNickname = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _ircService.PendingMessages.Subscribe(value => 
        {
            Debug.Log($"[IRCBridge] IRC Pending messages changed: {value}");
            JsPendingMessages = value; // Auto-generated property
        }).AddTo(_disposables);
        
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
        // Subscribe to Steam username changes (if Steam integration is available)
        if (_steamUserProfiles != null)
        {
            _steamUserProfiles.UserName.Subscribe(value => 
            {
                Debug.Log($"[IRCBridge] Steam username changed: {value}");
                JsSteamUsername = value; // Auto-generated property
                JsSteamReady = !string.IsNullOrEmpty(value);
            }).AddTo(_disposables);
        }
#endif
        
        // Subscribe to connection state changes
        _ircService.OnConnectionStateChanged.Subscribe(state => 
        {
            Debug.Log($"[IRCBridge] IRC Connection state changed: {state}");
            JsConnectionState = state.ToString(); // Auto-generated property
            
            // Refresh messages list when connection state changes
            RefreshMessagesList();
        }).AddTo(_disposables);
        
        // Subscribe to messages for reactive updates
        _ircService.OnMessageReceived.Subscribe(message =>
        {
            Debug.Log($"[IRCBridge] ✓ Received IRC message: {message.nickname}: {message.message}");

            // Update individual message properties
            JsLastMessage = FormatMessage(message);

            // Add formatted message to List<string>
            AddMessageToList(message);

            Debug.Log($"[IRCBridge] Updated message count to: {JsMessageCount}");
        }).AddTo(_disposables);
        
        // Subscribe to raw messages for debugging
        _ircService.OnRawMessageReceived.Subscribe(rawMessage => 
        {
            Debug.Log($"[IRCBridge] Raw IRC message received: {rawMessage}");
            JsLastRawMessage = rawMessage;
            
            // Force update message count on any raw message
            var newCount = _ircService.GetMessageCount();
            if (newCount != JsMessageCount)
            {
                Debug.Log($"[IRCBridge] Updating message count from {JsMessageCount} to {newCount}");
                JsMessageCount = newCount;
            }
        }).AddTo(_disposables);
        
        // Initialize current values immediately
        JsMessageCount = _ircService.GetMessageCount();
        JsIsConnected = _ircService.IsConnectedValue;
        JsCurrentChannel = _ircService.CurrentChannelValue;
        JsCurrentNickname = _ircService.CurrentNicknameValue;
        JsPendingMessages = _ircService.PendingMessagesValue;
        
        // Initialize the reactive messages list
        RefreshMessagesList();
        
        Debug.Log($"[IRCBridge] ✓ Initial values set - Messages: {JsMessageCount}, Connected: {JsIsConnected}, Channel: {JsCurrentChannel}");
        
        // Subscribe to errors
        _ircService.OnError.Subscribe(error => 
        {
            JsLastError = error; // Auto-generated property
            Debug.LogWarning($"[IRCBridge] IRC Error: {error}");
        }).AddTo(_disposables);
        
        // Subscribe to raw messages (optional, for debugging)
        _ircService.OnRawMessageReceived.Subscribe(raw => 
        {
            JsLastRawMessage = raw; // Auto-generated property
        }).AddTo(_disposables);
    }
    
    
    private string FormatMessage(IRCMessage message)
    {
        if (message.isChannelMessage || message.isPrivateMessage)
        {
            return $"[{message.timestamp:HH:mm:ss}] <{message.nickname}> {message.message}";
        }
        else if (message.isServerMessage)
        {
            return $"[{message.timestamp:HH:mm:ss}] * {message.message}";
        }
        else
        {
            return $"[{message.timestamp:HH:mm:ss}] {message.rawMessage}";
        }
    }
    
    private void UpdateChannelUsers()
    {
        // This would need to be implemented based on your IRC protocol handling
        // For now, just trigger an update event
        JsChannelUsers = new List<string>(_jsChannelUsers ?? new List<string>());
    }
    
    /// <summary>
    /// Refresh the reactive messages list from IRCService for live OneJS updates
    /// </summary>
    private void RefreshMessagesList()
    {
        if (_ircService == null)
        {
            Debug.LogWarning("[IRCBridge] Cannot refresh messages list - IRCService is null");
            // Clear and add status message as string
            JsMessagesList.Clear();
            JsMessagesList.Add("IRC Service not available");
            JsLatestMessage = new IRCMessage
            {
                message = "IRC Service not available",
                command = "STATUS",
                timestamp = DateTime.Now,
                isServerMessage = true
            };
            return;
        }

        try
        {
            // Get recent messages from service
            var messages = _ircService.GetRecentMessages(maxMessages);

            if (messages.Length == 0)
            {
                // Create status message as string
                var statusText = _ircService.IsConnectedValue ? "Connected to IRC - No messages yet..." : "Use Connect to join IRC chat";

                JsMessagesList.Clear();
                JsMessagesList.Add(statusText);
                JsLatestMessage = new IRCMessage
                {
                    message = statusText,
                    command = "STATUS",
                    timestamp = DateTime.Now,
                    isServerMessage = true
                };
            }
            else
            {
                // Update List<string> with formatted messages
                var currentCount = JsMessagesList.Count;

                // If we have different number of messages, clear and rebuild
                if (messages.Length != currentCount)
                {
                    JsMessagesList.Clear();
                    foreach (var msg in messages)
                    {
                        JsMessagesList.Add(FormatMessage(msg));
                    }

                    if (messages.Length > 0)
                    {
                        JsLatestMessage = messages[messages.Length - 1];
                    }
                }

                Debug.Log($"[IRCBridge] Refreshed messages list with {JsMessagesList.Count} formatted messages");
            }
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Error refreshing messages list: {ex.Message}");
            var errorText = $"Error loading messages: {ex.Message}";
            JsMessagesList.Clear();
            JsMessagesList.Add(errorText);
            JsLatestMessage = new IRCMessage
            {
                message = errorText,
                command = "ERROR",
                timestamp = DateTime.Now,
                isServerMessage = true
            };
        }
    }

    /// <summary>
    /// Add a single message to the List<string> and trim if needed
    /// </summary>
    private void AddMessageToList(IRCMessage message)
    {
        if (message == null) return;

        var formattedMessage = FormatMessage(message);
        JsMessagesList.Add(formattedMessage);
        JsLatestMessage = message;

        // Trim old messages if we exceed the limit
        while (JsMessagesList.Count > maxMessages)
        {
            JsMessagesList.RemoveAt(0);
        }

        JsMessageCount = JsMessagesList.Count;
    }

    #endregion

    #region OneJS Public Methods - Connection Management
    
    /// <summary>
    /// Connect to IRC server asynchronously
    /// </summary>
    public async UniTask<bool> JsConnectAsync()
    {
        // First check if service is available
        if (_ircService == null)
        {
            Debug.LogWarning("[IRCBridge] IRCService not found, attempting to find it...");
            
            // Try to find the service again
            await TryFindIRCServiceAsync();
            
            if (_ircService == null)
            {
                Debug.LogError("[IRCBridge] IRCService still not available after search - cannot connect");
                JsLastError = "IRCService not available";
                return false;
            }
            else
            {
                Debug.Log("[IRCBridge] Found IRCService, proceeding with connection");
                // Re-initialize bindings since we just found the service
                InitializeBindings();
            }
        }
        
        try
        {
            Debug.Log($"[IRCBridge] Connecting to IRC server...");
            Debug.Log($"[IRCBridge] Current IRCService state - IsConnected: {_ircService.IsConnectedValue}");
            var result = await _ircService.ConnectAsync(this.GetCancellationTokenOnDestroy());
            Debug.Log($"[IRCBridge] Connection result: {result}");
            return result;
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Connection failed: {ex.Message}");
            JsLastError = ex.Message;
            return false;
        }
    }
    
    /// <summary>
    /// Connect to IRC with custom configuration
    /// </summary>
    public async UniTask<bool> JsConnectWithConfigAsync(string nickname, string channel = null)
    {
        if (_ircService == null)
        {
            Debug.LogError("[IRCBridge] IRCService not available");
            return false;
        }
        
        try
        {
            // Update nickname before connecting
            JsSetNickname(nickname);
            
            // Connect
            var connected = await JsConnectAsync();
            
            // Join channel if specified
            if (connected && !string.IsNullOrEmpty(channel))
            {
                await UniTask.Delay(500); // Brief delay to ensure connection is stable
                JsJoinChannel(channel);
            }
            
            return connected;
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Connection with config failed: {ex.Message}");
            JsLastError = ex.Message;
            return false;
        }
    }
    
    /// <summary>
    /// Disconnect from IRC server
    /// </summary>
    public void JsDisconnect()
    {
        if (_ircService == null)
        {
            Debug.LogWarning("[IRCBridge] IRCService not found, attempting to find it...");
            
            // Try to find the service synchronously (can't use async in void method)
            var lifetimeScope = FindAnyObjectByType<LifetimeScope>();
            if (lifetimeScope?.Container != null)
            {
                if (lifetimeScope.Container.TryResolve<IIRCService>(out var ircService))
                {
                    _ircService = ircService;
                    Debug.Log("[IRCBridge] Found IRCService for disconnect");
                    InitializeBindings();
                }
            }
            
            if (_ircService == null)
            {
                Debug.LogError("[IRCBridge] IRCService still not available - cannot disconnect");
                JsLastError = "IRCService not available";
                return;
            }
        }
        
        Debug.Log($"[IRCBridge] Disconnecting from IRC - Current state: {_ircService.IsConnectedValue}");
        _ircService.Disconnect();
        Debug.Log("[IRCBridge] Disconnected from IRC");
    }
    
    /// <summary>
    /// Reconnect to IRC server (disconnect then connect)
    /// </summary>
    public async UniTask<bool> JsReconnectAsync()
    {
        // First check if service is available
        if (_ircService == null)
        {
            Debug.LogWarning("[IRCBridge] IRCService not found, attempting to find it...");
            
            // Try to find the service again
            await TryFindIRCServiceAsync();
            
            if (_ircService == null)
            {
                Debug.LogError("[IRCBridge] IRCService still not available after search - cannot reconnect");
                JsLastError = "IRCService not available";
                return false;
            }
            else
            {
                Debug.Log("[IRCBridge] Found IRCService, proceeding with reconnection");
                // Re-initialize bindings since we just found the service
                InitializeBindings();
            }
        }
        
        try
        {
            Debug.Log("[IRCBridge] Starting reconnection process using IRCService.ReconnectAsync()...");
            Debug.Log($"[IRCBridge] Current IRCService state - IsConnected: {_ircService.IsConnectedValue}");
            
            // Use the new dedicated ReconnectAsync method from IRCService
            var result = await _ircService.ReconnectAsync(this.GetCancellationTokenOnDestroy());
            
            if (result)
            {
                Debug.Log("[IRCBridge] Reconnection successful");
            }
            else
            {
                Debug.LogWarning("[IRCBridge] Reconnection failed");
            }
            
            return result;
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Reconnection error: {ex.Message}");
            JsLastError = ex.Message;
            return false;
        }
    }
    
    /// <summary>
    /// Try to find IRCService if not already available using proper Container API
    /// </summary>
    private async UniTask TryFindIRCServiceAsync()
    {
        try
        {
            // First priority: Use the injected container if available
            if (_container != null)
            {
                Debug.Log("[IRCBridge] Using injected container to resolve services");
                
                if (_ircService == null && _container.TryResolve<IIRCService>(out var ircService))
                {
                    _ircService = ircService;
                    Debug.Log("[IRCBridge] Successfully found IRCService through injected container");
                }
                
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
                if (_steamUserProfiles == null && _container.TryResolve<SteamUserProfiles>(out var steamProfiles))
                {
                    _steamUserProfiles = steamProfiles;
                    Debug.Log("[IRCBridge] Also found SteamUserProfiles through injected container");
                }
#endif
            }
            
            // Second priority: Use the specific SSDBLifetimeScope
            if (_ircService == null)
            {
                var ssdbScope = FindAnyObjectByType<SSDBLifetimeScope>();
                if (ssdbScope?.Container != null)
                {
                    Debug.Log("[IRCBridge] Using SSDBLifetimeScope to resolve services");
                    
                    if (ssdbScope.Container.TryResolve<IIRCService>(out var ircService))
                    {
                        _ircService = ircService;
                        Debug.Log("[IRCBridge] Successfully found IRCService through SSDBLifetimeScope");
                        
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
                        // Also try to find SteamUserProfiles if needed
                        if (_steamUserProfiles == null && ssdbScope.Container.TryResolve<SteamUserProfiles>(out var steamProfiles))
                        {
                            _steamUserProfiles = steamProfiles;
                            Debug.Log("[IRCBridge] Also found SteamUserProfiles through SSDBLifetimeScope");
                        }
#endif
                    }
                }
            }
            
            // Give it a moment to settle
            await UniTask.Delay(100, cancellationToken: this.GetCancellationTokenOnDestroy());
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Error finding IRCService: {ex.Message}");
        }
    }
    
    /// <summary>
    /// Check if connected to IRC
    /// </summary>
    public bool JsIsConnectedToIRC()
    {
        return _ircService?.IsConnectedValue ?? false;
    }
    
    #endregion
    
    #region OneJS Public Methods - Messaging
    
    /// <summary>
    /// Send a message to the current channel
    /// </summary>
    public void JsSendMessage(string message)
    {
        if (_ircService != null && !string.IsNullOrEmpty(JsCurrentChannel))
        {
            _ircService.SendMessage(JsCurrentChannel, message);
            Debug.Log($"[IRCBridge] Sent message to {JsCurrentChannel}: {message}");

            // Add the sent message to local message history immediately
            // This ensures the user sees their own messages in the chat
            var sentMessage = new IRCMessage
            {
                message = message,
                nickname = JsCurrentNickname,
                channel = JsCurrentChannel,
                timestamp = DateTime.Now,
                isChannelMessage = true,
                command = "PRIVMSG"
            };

            // Add formatted message to the local list
            var formattedMessage = FormatMessage(sentMessage);
            JsMessagesList.Add(formattedMessage);
            JsLatestMessage = sentMessage;

            // Trim old messages if we exceed the limit
            while (JsMessagesList.Count > maxMessages)
            {
                JsMessagesList.RemoveAt(0);
            }

            // Update message count
            JsMessageCount = JsMessagesList.Count;

            Debug.Log($"[IRCBridge] Added sent message to local history. Total messages: {JsMessageCount}");
        }
        else
        {
            Debug.LogWarning("[IRCBridge] Cannot send message - no channel joined");
        }
    }
    
    /// <summary>
    /// Send a message to a specific channel
    /// </summary>
    public void JsSendMessageToChannel(string channel, string message)
    {
        if (_ircService != null)
        {
            _ircService.SendMessage(channel, message);
            Debug.Log($"[IRCBridge] Sent message to {channel}: {message}");

            // Add the sent message to local message history if it's the current channel
            if (string.Equals(channel, JsCurrentChannel, StringComparison.OrdinalIgnoreCase))
            {
                var sentMessage = new IRCMessage
                {
                    message = message,
                    nickname = JsCurrentNickname,
                    channel = channel,
                    timestamp = DateTime.Now,
                    isChannelMessage = true,
                    command = "PRIVMSG"
                };

                // Add formatted message to the local list
                var formattedMessage = FormatMessage(sentMessage);
                JsMessagesList.Add(formattedMessage);
                JsLatestMessage = sentMessage;

                // Trim old messages if we exceed the limit
                while (JsMessagesList.Count > maxMessages)
                {
                    JsMessagesList.RemoveAt(0);
                }

                // Update message count
                JsMessageCount = JsMessagesList.Count;

                Debug.Log($"[IRCBridge] Added sent message to local history. Total messages: {JsMessageCount}");
            }
        }
    }
    
    /// <summary>
    /// Send a private message to a user
    /// </summary>
    public void JsSendPrivateMessage(string nickname, string message)
    {
        if (_ircService != null)
        {
            _ircService.SendMessage(nickname, message);
            Debug.Log($"[IRCBridge] Sent private message to {nickname}: {message}");
        }
    }
    
    /// <summary>
    /// Send a raw IRC command
    /// </summary>
    public void JsSendRawCommand(string command)
    {
        if (_ircService != null)
        {
            _ircService.SendRawCommand(command);
            Debug.Log($"[IRCBridge] Sent raw command: {command}");
        }
    }
    
    #endregion
    
    #region OneJS Public Methods - Channel Management
    
    /// <summary>
    /// Join an IRC channel
    /// </summary>
    public void JsJoinChannel(string channel)
    {
        if (_ircService != null)
        {
            _ircService.JoinChannel(channel);
            Debug.Log($"[IRCBridge] Joining channel: {channel}");
        }
    }
    
    /// <summary>
    /// Leave an IRC channel
    /// </summary>
    public void JsLeaveChannel(string channel)
    {
        if (_ircService != null)
        {
            _ircService.LeaveChannel(channel);
            Debug.Log($"[IRCBridge] Leaving channel: {channel}");
        }
    }
    
    /// <summary>
    /// Leave the current channel
    /// </summary>
    public void JsLeaveCurrentChannel()
    {
        if (_ircService != null && !string.IsNullOrEmpty(JsCurrentChannel))
        {
            _ircService.LeaveChannel(JsCurrentChannel);
            Debug.Log($"[IRCBridge] Left channel: {JsCurrentChannel}");
        }
    }
    
    #endregion
    
    #region OneJS Public Methods - User Management
    
    /// <summary>
    /// Set nickname (must be done before connecting)
    /// </summary>
    public void JsSetNickname(string nickname)
    {
        // This would need to be implemented in IRCService
        // For now, just update the local tracking
        Debug.Log($"[IRCBridge] Setting nickname: {nickname}");
        // You'd need to add this functionality to IRCService
    }
    
    /// <summary>
    /// Get the current nickname
    /// </summary>
    public string JsGetNickname()
    {
        return JsCurrentNickname;
    }
    
    #endregion
    
    #region OneJS Public Methods - Message History
    
    /// <summary>
    /// Get recent messages directly from IRCService
    /// </summary>
    public string[] JsGetRecentMessages(int count = 50)
    {
        Debug.Log($"[IRCBridge] JsGetRecentMessages called with count={count}");
        
        if (_ircService == null)
        {
            Debug.LogError("[IRCBridge] IRCService is null in JsGetRecentMessages!");
            return new string[0];
        }
        
        var messages = _ircService.GetRecentMessages(count);
        Debug.Log($"[IRCBridge] IRCService returned {messages.Length} messages");
        
        if (messages.Length == 0)
        {
            // Additional diagnostics
            Debug.Log($"[IRCBridge] No messages found. Service stats:");
            Debug.Log($"[IRCBridge]   - Total message count: {_ircService.GetMessageCount()}");
            Debug.Log($"[IRCBridge]   - Is connected: {_ircService.IsConnectedValue}");
            Debug.Log($"[IRCBridge]   - Current channel: {_ircService.CurrentChannelValue}");
            Debug.Log($"[IRCBridge]   - Pending messages: {_ircService.PendingMessagesValue}");
        }
        
        var formattedMessages = new string[messages.Length];
        
        for (int i = 0; i < messages.Length; i++)
        {
            formattedMessages[i] = FormatMessage(messages[i]);
            Debug.Log($"[IRCBridge] Message {i}: {formattedMessages[i]}");
        }
        
        return formattedMessages;
    }
    
    /// <summary>
    /// Get recent messages as IRCMessage objects for advanced processing
    /// </summary>
    public IRCMessage[] JsGetRecentMessagesRaw(int count = 50)
    {
        if (_ircService == null)
            return new IRCMessage[0];
        
        return _ircService.GetRecentMessages(count);
    }
    
    /// <summary>
    /// Get total message count from IRCService
    /// </summary>
    public int JsGetTotalMessageCount()
    {
        return _ircService?.GetMessageCount() ?? 0;
    }
    
    /// <summary>
    /// Get the latest message
    /// </summary>
    public string JsGetLatestMessage()
    {
        if (_ircService == null)
            return string.Empty;
        
        var latestMessage = _ircService.GetLatestMessage();
        return latestMessage != null ? FormatMessage(latestMessage) : string.Empty;
    }
    
    /// <summary>
    /// Get the latest message as raw IRCMessage object
    /// </summary>
    public IRCMessage JsGetLatestMessageRaw()
    {
        return _ircService?.GetLatestMessage();
    }
    
    /// <summary>
    /// Get messages filtered by type (channel, private, server)
    /// </summary>
    public string[] JsGetMessagesByType(string messageType, int count = 50)
    {
        if (_ircService == null)
            return new string[0];
        
        var allMessages = _ircService.GetRecentMessages(count);
        var filteredMessages = new List<string>();
        
        foreach (var message in allMessages)
        {
            bool includeMessage = messageType.ToLower() switch
            {
                "channel" => message.isChannelMessage,
                "private" => message.isPrivateMessage,
                "server" => message.isServerMessage,
                "all" => true,
                _ => true
            };
            
            if (includeMessage)
            {
                filteredMessages.Add(FormatMessage(message));
            }
        }
        
        return filteredMessages.ToArray();
    }
    
    /// <summary>
    /// Get messages from a specific channel
    /// </summary>
    public string[] JsGetChannelMessages(string channel, int count = 50)
    {
        if (_ircService == null || string.IsNullOrEmpty(channel))
            return new string[0];
        
        var allMessages = _ircService.GetRecentMessages(count * 2); // Get more to filter
        var channelMessages = new List<string>();
        
        foreach (var message in allMessages)
        {
            if (message.isChannelMessage && 
                string.Equals(message.channel, channel, StringComparison.OrdinalIgnoreCase))
            {
                channelMessages.Add(FormatMessage(message));
                
                if (channelMessages.Count >= count)
                    break;
            }
        }
        
        return channelMessages.ToArray();
    }
    
    /// <summary>
    /// Get the number of pending messages (unprocessed)
    /// </summary>
    public int JsGetPendingMessageCount()
    {
        return JsPendingMessages;
    }
    
    #endregion
    
    #region OneJS Public Methods - Utility
    
    /// <summary>
    /// Get connection status string
    /// </summary>
    public string JsGetConnectionStatus()
    {
        if (_ircService == null)
            return "Service Unavailable";
        
        return JsConnectionState;
    }
    
    /// <summary>
    /// Get a formatted summary of the current IRC state
    /// </summary>
    public string JsGetIRCSummary()
    {
        if (_ircService == null)
            return "IRC Service not available";
        
        if (!JsIsConnected)
            return "Disconnected from IRC";
        
        return $"Connected as {JsCurrentNickname} in {JsCurrentChannel}";
    }
    
    /// <summary>
    /// Check if the service is available
    /// </summary>
    public bool JsIsServiceAvailable()
    {
        return _ircService != null;
    }
    
    /// <summary>
    /// Get the last error message
    /// </summary>
    public string JsGetLastError()
    {
        return JsLastError;
    }
    
    /// <summary>
    /// Get statistics about the message buffer
    /// </summary>
    public string JsGetMessageStats()
    {
        if (_ircService == null)
            return "IRC Service not available";
        
        var totalMessages = _ircService.GetMessageCount();
        var pendingMessages = JsPendingMessages;
        
        return $"Messages: {totalMessages} total, {pendingMessages} pending";
    }
    
    #endregion
    
#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID
    #region OneJS Public Methods - Steam Integration
    
    /// <summary>
    /// Get username from Steam ID (with caching)
    /// Accepts formats: "S76561198123456789" or "76561198123456789"
    /// </summary>
    /// <param name="steamId">The Steam ID with or without 'S' prefix</param>
    /// <returns>A promise that resolves to the username or null</returns>
    public async UniTask<string> JsUsernameFromSteamID(string steamId)
    {
        if (_steamUserProfiles == null)
        {
            Debug.LogWarning("[IRCBridge] Steam integration not available");
            return null;
        }
        
        if (string.IsNullOrEmpty(steamId))
        {
            Debug.LogWarning("[IRCBridge] Empty Steam ID provided");
            return null;
        }
        
        try
        {
            Debug.Log($"[IRCBridge] Looking up username for Steam ID: {steamId}");
            
            // Use the cached lookup from SteamUserProfiles
            var username = await _steamUserProfiles.GetUsernameFromSteamIdAsync(
                steamId, 
                this.GetCancellationTokenOnDestroy()
            );
            
            if (!string.IsNullOrEmpty(username))
            {
                Debug.Log($"[IRCBridge] Found username for {steamId}: {username}");
            }
            else
            {
                Debug.Log($"[IRCBridge] Could not find username for {steamId}");
            }
            
            return username;
        }
        catch (Exception ex)
        {
            Debug.LogError($"[IRCBridge] Error looking up Steam ID {steamId}: {ex.Message}");
            return null;
        }
    }
    
    /// <summary>
    /// Batch lookup of usernames from Steam IDs
    /// </summary>
    /// <param name="steamIds">Array of Steam IDs</param>
    /// <returns>Dictionary mapping Steam IDs to usernames</returns>
    public async UniTask<Dictionary<string, string>> JsBatchUsernamesFromSteamIDs(string[] steamIds)
    {
        var results = new Dictionary<string, string>();
        
        if (_steamUserProfiles == null || steamIds == null || steamIds.Length == 0)
        {
            return results;
        }
        
        // Process in parallel but limit concurrency to avoid overwhelming Steam API
        const int maxConcurrency = 5;
        var semaphore = new SemaphoreSlim(maxConcurrency);
        var tasks = new List<UniTask>();
        
        foreach (var steamId in steamIds)
        {
            if (string.IsNullOrEmpty(steamId)) continue;
            
            tasks.Add(ProcessSteamIdAsync(steamId, results, semaphore));
        }
        
        await UniTask.WhenAll(tasks);
        
        return results;
    }
    
    private async UniTask ProcessSteamIdAsync(string steamId, Dictionary<string, string> results, SemaphoreSlim semaphore)
    {
        await semaphore.WaitAsync();
        try
        {
            var username = await JsUsernameFromSteamID(steamId);
            if (!string.IsNullOrEmpty(username))
            {
                lock (results)
                {
                    results[steamId] = username;
                }
            }
        }
        finally
        {
            semaphore.Release();
        }
    }
    
    /// <summary>
    /// Clear the Steam username cache
    /// </summary>
    public void JsClearSteamUsernameCache()
    {
        if (_steamUserProfiles != null)
        {
            _steamUserProfiles.ClearUsernameCache();
            Debug.Log("[IRCBridge] Steam username cache cleared");
        }
    }
    
    /// <summary>
    /// Get Steam cache statistics for debugging
    /// </summary>
    public string JsGetSteamCacheStats()
    {
        if (_steamUserProfiles == null)
            return "Steam integration not available";
        
        var stats = _steamUserProfiles.GetCacheStats();
        return $"Cache: {stats.totalEntries} total, {stats.validEntries} valid, {stats.expiredEntries} expired";
    }
    
    /// <summary>
    /// Check if Steam integration is available
    /// </summary>
    public bool JsIsSteamAvailable()
    {
        return _steamUserProfiles != null && JsSteamReady;
    }
    
    /// <summary>
    /// Format an IRC message with Steam username lookup
    /// </summary>
    public async UniTask<string> JsFormatMessageWithSteamName(IRCMessage message)
    {
        if (message == null) return string.Empty;
        
        // Check if nickname is a Steam ID (starts with 'S' followed by numbers)
        if (!string.IsNullOrEmpty(message.nickname) && 
            message.nickname.StartsWith("S") && 
            message.nickname.Length > 1 &&
            message.nickname[1..].All(char.IsDigit))
        {
            var username = await JsUsernameFromSteamID(message.nickname);
            if (!string.IsNullOrEmpty(username))
            {
                return $"[{message.timestamp:HH:mm:ss}] <{username}> {message.message}";
            }
        }
        
        // Fallback to regular formatting
        return FormatMessage(message);
    }
    
    #endregion
#endif
}