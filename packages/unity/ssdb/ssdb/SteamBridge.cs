#if !UNITY_WEBGL && !UNITY_IOS && !UNITY_ANDROID

using System;
using UnityEngine;
using OneJS;
using Puerts;
using R3;
using VContainer;
using VContainer.Unity;
using KBVE.SSDB.Steam;
using Cysharp.Threading.Tasks;
using System.Threading;
using MoreMountains.Tools;


/// <summary>
/// OneJS Bridge for Steam user profile data
/// This class should be attached to a GameObject in the scene for OneJS to reference
/// It syncs with the VContainer-injected SteamUserProfiles instance
/// Uses simpler namespace for OneJS Source Generator compatibility
/// </summary>
public partial class SteamBridge : MonoBehaviour
{
    private SteamUserProfiles _steamUserProfiles;
    private readonly CompositeDisposable _disposables = new();

    [Header("Debug Settings")]
    [SerializeField] private bool enableDiagnostics = false;

    /// <summary>
    /// Helper method to log diagnostic messages only when diagnostics are enabled
    /// </summary>
    private void LogDiagnostic(string message)
    {
        if (enableDiagnostics)
        {
            Debug.Log($"[SteamBridge] {message}");
        }
    }

    /// <summary>
    /// Helper method to log diagnostic warnings only when diagnostics are enabled
    /// </summary>
    private void LogDiagnosticWarning(string message)
    {
        if (enableDiagnostics)
        {
            Debug.LogWarning($"[SteamBridge] {message}");
        }
    }

    /// <summary>
    /// Helper method to log diagnostic errors only when diagnostics are enabled
    /// </summary>
    private void LogDiagnosticError(string message)
    {
        if (enableDiagnostics)
        {
            Debug.LogError($"[SteamBridge] {message}");
        }
    }

    #region OneJS EventfulProperty Fields
    
    // EventfulProperty fields for OneJS bidirectional binding
    // OneJS Source Generator will auto-create properties and events
    [EventfulProperty] string _jsUserName = string.Empty;
    [EventfulProperty] string _jsUserStatus = "Offline";
    [EventfulProperty] string _jsUserSteamId = string.Empty;
    [EventfulProperty] bool _jsIsOnline = false;
    [EventfulProperty] bool _jsIsInGame = false;
    [EventfulProperty] int _jsUserLevel = 0;
    [EventfulProperty] string _jsCurrentGameName = string.Empty;
    [EventfulProperty] int _jsFriendCount = 0;
    [EventfulProperty] Texture2D _jsUserAvatar = null;
    
    // Auto-generated by EventfulProperty:
    // - public string JsUserName { get; set; }
    // - public event Action<string> OnJsUserNameChanged;
    // - etc. for all fields above
    
    #endregion

    #region Unity Lifecycle
    
    private void Start()
    {
        // Find the SteamUserProfiles instance from VContainer using UniTask
        InitializeSteamConnection().Forget();
    }
    
    private void OnDestroy()
    {
        _disposables.Dispose();
    }
    
    #endregion
    
    #region Initialization
    
    private async UniTaskVoid InitializeSteamConnection()
    {
        try
        {
            // Use UniTask for non-blocking async initialization
            await WaitForSteamUserProfilesAsync();
        }
        catch (OperationCanceledException)
        {
            LogDiagnosticWarning("Steam connection initialization was cancelled or timed out");
        }
        catch (Exception ex)
        {
            LogDiagnosticError($"Failed to initialize Steam connection: {ex.Message}");
        }
    }
    
    private async UniTask WaitForSteamUserProfilesAsync()
    {
        // Set a 30-second timeout for finding SteamUserProfiles
        using var timeoutCts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
        var destroyCancellationToken = this.GetCancellationTokenOnDestroy();
        
        // Combine timeout and destroy tokens
        using var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(
            timeoutCts.Token, 
            destroyCancellationToken
        );
        
        LogDiagnostic("Starting async search for SteamUserProfiles...");
        
        while (_steamUserProfiles == null)
        {
            linkedCts.Token.ThrowIfCancellationRequested();
            
            try
            {
                // Method 1: Try to find it through VContainer's resolver
                var lifetimeScope = FindAnyObjectByType<LifetimeScope>();
                if (lifetimeScope?.Container != null)
                {
                    if (lifetimeScope.Container.TryResolve<SteamUserProfiles>(out var steamProfiles))
                    {
                        _steamUserProfiles = steamProfiles;
                        LogDiagnostic("Found SteamUserProfiles through VContainer");
                        InitializeBindings();
                        return;
                    }
                }
                
                // Method 2: Try to find it as a component in the scene
                var steamProfilesComponent = FindAnyObjectByType<SteamUserProfiles>();
                if (steamProfilesComponent != null)
                {
                    _steamUserProfiles = steamProfilesComponent;
                    LogDiagnostic("Found SteamUserProfiles as scene component");
                    InitializeBindings();
                    return;
                }
            }
            catch (Exception ex)
            {
                LogDiagnosticWarning($"Error finding SteamUserProfiles: {ex.Message}");
            }
            
            // Non-blocking delay using UniTask
            await UniTask.Delay(500, cancellationToken: linkedCts.Token);
        }
    }
    
    #endregion
    
    #region Data Binding
    
    private void InitializeBindings()
    {
        if (_steamUserProfiles == null) return;
        
        LogDiagnostic("Initializing OneJS bindings with SteamUserProfiles");
        
        // Subscribe to all reactive properties from SteamUserProfiles
        // Use auto-generated properties from EventfulProperty
        _steamUserProfiles.UserName.Subscribe(value => 
        {
            JsUserName = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _steamUserProfiles.UserStatus.Subscribe(value => 
        {
            JsUserStatus = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _steamUserProfiles.UserSteamId.Subscribe(value => 
        {
            JsUserSteamId = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _steamUserProfiles.IsOnline.Subscribe(value => 
        {
            JsIsOnline = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _steamUserProfiles.IsInGame.Subscribe(value => 
        {
            JsIsInGame = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _steamUserProfiles.UserLevel.Subscribe(value => 
        {
            JsUserLevel = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _steamUserProfiles.CurrentGameName.Subscribe(value => 
        {
            JsCurrentGameName = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _steamUserProfiles.FriendCount.Subscribe(value => 
        {
            JsFriendCount = value; // Auto-generated property
        }).AddTo(_disposables);
        
        _steamUserProfiles.UserAvatar.Subscribe(value => 
        {
            JsUserAvatar = value; // Auto-generated property
        }).AddTo(_disposables);
    }
    
    #endregion
    
    #region OneJS Public Methods
    
    /// <summary>
    /// Force refresh all user data from Steam
    /// </summary>
    public void JsRefreshAllData()
    {
        if (_steamUserProfiles != null)
        {
            _steamUserProfiles.RefreshUserData();
            _steamUserProfiles.RefreshAvatar();
        }
    }
    
    /// <summary>
    /// Get a formatted string of user info for display
    /// </summary>
    public string JsGetUserSummary()
    {
        if (_steamUserProfiles != null)
        {
            return $"{_steamUserProfiles.UserName.Value} (Level {_steamUserProfiles.UserLevel.Value}) - {_steamUserProfiles.UserStatus.Value}";
        }
        return "Steam not available";
    }
    
    /// <summary>
    /// Check if user has a specific achievement
    /// </summary>
    public bool JsHasAchievement(string achievementId)
    {
        // This would need to be implemented with achievement checking
        // For now, return false as placeholder
        LogDiagnostic($"Checking achievement: {achievementId}");
        return false;
    }
    
    /// <summary>
    /// Get user's play time for current game in hours
    /// </summary>
    public float JsGetCurrentGamePlayTime()
    {
        // This would need Steam API integration for playtime
        // Return 0 as placeholder
        return 0f;
    }
    
    /// <summary>
    /// Get user's friend list count
    /// </summary>
    public int JsGetFriendCount()
    {
        return _steamUserProfiles?.FriendCount.Value ?? 0;
    }
    
    /// <summary>
    /// Check if user is playing a specific game by ID
    /// </summary>
    public bool JsIsPlayingGame(ulong gameId)
    {
        return _steamUserProfiles?.IsInGame.Value == true && 
               _steamUserProfiles?.CurrentGameId.Value == gameId;
    }
    
    /// <summary>
    /// Get connection status for debugging
    /// </summary>
    public bool JsIsConnected()
    {
        return _steamUserProfiles != null;
    }
    
    #endregion
    
    #region Scene Management Methods
    
    /// <summary>
    /// Load a scene using MoreMountains Scene Loading Manager
    /// </summary>
    /// <param name="sceneName">The name of the scene to load</param>
    /// <param name="loadingSceneName">Optional loading scene to show during transition</param>
    public void JsLoadScene(string sceneName, string loadingSceneName = "")
    {
        if (string.IsNullOrEmpty(loadingSceneName))
        {
            MMSceneLoadingManager.LoadScene(sceneName);
            LogDiagnostic($"Loading scene: {sceneName}");
        }
        else
        {
            MMSceneLoadingManager.LoadScene(sceneName, loadingSceneName);
            LogDiagnostic($"Loading scene: {sceneName} with loading screen: {loadingSceneName}");
        }
    }
    
    /// <summary>
    /// Load a scene additively using MoreMountains Additive Scene Loading Manager
    /// </summary>
    /// <param name="sceneName">The name of the scene to load additively</param>
    /// <param name="loadingSceneName">Optional loading scene name</param>
    public void JsLoadSceneAdditive(string sceneName, string loadingSceneName = "")
    {
        var settings = new MMAdditiveSceneLoadingManagerSettings
        {
            LoadingSceneName = loadingSceneName,
            UnloadMethod = MMAdditiveSceneLoadingManagerSettings.UnloadMethods.None
        };
        
        MMAdditiveSceneLoadingManager.LoadScene(sceneName, settings);
        LogDiagnostic($"Loading scene additively: {sceneName}");
    }
    
    /// <summary>
    /// Load a scene additively with full control over settings
    /// </summary>
    /// <param name="sceneName">The name of the scene to load additively</param>
    /// <param name="unloadActiveScene">Whether to unload the currently active scene</param>
    /// <param name="loadingSceneName">Optional loading scene name</param>
    public void JsLoadSceneAdditiveAdvanced(string sceneName, bool unloadActiveScene = false, string loadingSceneName = "")
    {
        var settings = new MMAdditiveSceneLoadingManagerSettings
        {
            LoadingSceneName = loadingSceneName,
            UnloadMethod = unloadActiveScene 
                ? MMAdditiveSceneLoadingManagerSettings.UnloadMethods.ActiveScene 
                : MMAdditiveSceneLoadingManagerSettings.UnloadMethods.None,
            ThreadPriority = UnityEngine.ThreadPriority.High,
            SecureLoad = true,
            InterpolateProgress = true
        };
        
        MMAdditiveSceneLoadingManager.LoadScene(sceneName, settings);
        LogDiagnostic($"Loading scene additively (advanced): {sceneName}, unload active: {unloadActiveScene}");
    }
    
    /// <summary>
    /// Load a scene asynchronously with progress tracking using UniTask
    /// </summary>
    /// <param name="sceneName">The name of the scene to load</param>
    /// <returns>A promise that can be awaited in JS</returns>
    public async UniTask<bool> JsLoadSceneAsync(string sceneName)
    {
        try
        {
            LogDiagnostic($"Starting async load of scene: {sceneName}");
            
            var operation = UnityEngine.SceneManagement.SceneManager.LoadSceneAsync(sceneName);
            if (operation == null)
            {
                LogDiagnosticError($"Failed to start loading scene: {sceneName}");
                return false;
            }
            
            // Wait for the scene to load
            await operation.ToUniTask();
            
            LogDiagnostic($"Successfully loaded scene: {sceneName}");
            return true;
        }
        catch (Exception ex)
        {
            LogDiagnosticError($"Error loading scene {sceneName}: {ex.Message}");
            return false;
        }
    }
    
    /// <summary>
    /// Unload a scene asynchronously
    /// </summary>
    /// <param name="sceneName">The name of the scene to unload</param>
    /// <returns>A promise that can be awaited in JS</returns>
    public async UniTask<bool> JsUnloadSceneAsync(string sceneName)
    {
        try
        {
            LogDiagnostic($"Starting async unload of scene: {sceneName}");
            
            var operation = UnityEngine.SceneManagement.SceneManager.UnloadSceneAsync(sceneName);
            if (operation == null)
            {
                LogDiagnosticError($"Failed to start unloading scene: {sceneName}");
                return false;
            }
            
            // Wait for the scene to unload
            await operation.ToUniTask();
            
            LogDiagnostic($"Successfully unloaded scene: {sceneName}");
            return true;
        }
        catch (Exception ex)
        {
            LogDiagnosticError($"Error unloading scene {sceneName}: {ex.Message}");
            return false;
        }
    }
    
    /// <summary>
    /// Get the current active scene name
    /// </summary>
    /// <returns>The name of the currently active scene</returns>
    public string JsGetCurrentSceneName()
    {
        return UnityEngine.SceneManagement.SceneManager.GetActiveScene().name;
    }
    
    #endregion
}

#endif