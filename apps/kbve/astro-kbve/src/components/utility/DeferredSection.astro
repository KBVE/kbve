---
/**
 * DeferredSection - Defers component rendering until visible
 * Uses IntersectionObserver to load content only when approaching viewport
 * Includes skeleton placeholder to prevent CLS (Cumulative Layout Shift)
 */

interface Props {
	/** Unique identifier for this section */
	id: string;
	/** Minimum height for skeleton (prevents CLS) */
	minHeight?: string;
	/** Minimum height for mobile screens */
	minHeightMobile?: string;
	/** Root margin for IntersectionObserver (load earlier) */
	rootMargin?: string;
	/** CSS class for the container */
	class?: string;
	/** Background color for skeleton */
	skeletonBg?: string;
}

const {
	id,
	minHeight = '400px',
	minHeightMobile = '',
	rootMargin = '200px',
	class: className = '',
	skeletonBg = 'var(--sl-color-bg-accent, #1e293b)',
} = Astro.props;

const mobileHeight = minHeightMobile || minHeight;
---

<deferred-section
	data-deferred-id={id}
	data-root-margin={rootMargin}
	class:list={['deferred-section', className]}
	style={`--desktop-height: ${minHeight}; --mobile-height: ${mobileHeight};`}>
	<!-- Skeleton placeholder (shown until content loads) -->
	<div
		class="deferred-skeleton"
		aria-hidden="true"
		style={`background: ${skeletonBg};`}>
		<div class="skeleton-pulse"></div>
	</div>

	<!-- Actual content (hidden in template until intersection) -->
	<template data-deferred-content>
		<slot />
	</template>

	<!-- Fallback for no-JS: content renders immediately -->
	<noscript>
		<slot />
	</noscript>
</deferred-section>

<style>
	.deferred-section {
		position: relative;
		width: 100%;
		min-height: var(--desktop-height);
	}

	@media (max-width: 640px) {
		.deferred-section {
			min-height: var(--mobile-height);
		}
	}

	.deferred-skeleton {
		position: absolute;
		inset: 0;
		display: flex;
		align-items: center;
		justify-content: center;
		opacity: 1;
		transition: opacity 0.3s ease-out;
		border-radius: 0.5rem;
	}

	.deferred-section.loaded .deferred-skeleton {
		opacity: 0;
		pointer-events: none;
	}

	.skeleton-pulse {
		width: 60%;
		height: 40%;
		max-width: 200px;
		max-height: 100px;
		background: linear-gradient(
			90deg,
			transparent 0%,
			var(--sl-color-accent-low, rgba(6, 182, 212, 0.1)) 50%,
			transparent 100%
		);
		background-size: 200% 100%;
		animation: skeleton-shimmer 1.5s ease-in-out infinite;
		border-radius: 8px;
	}

	@keyframes skeleton-shimmer {
		0% {
			background-position: 200% 0;
		}
		100% {
			background-position: -200% 0;
		}
	}

	@media (prefers-reduced-motion: reduce) {
		.skeleton-pulse {
			animation: none;
			background: var(--sl-color-accent-low, rgba(6, 182, 212, 0.1));
		}
	}

	/* Hide noscript content when JS is enabled */
	.deferred-section noscript {
		display: none;
	}
</style>

<script>
	class DeferredSection extends HTMLElement {
		private observer: IntersectionObserver | null = null;
		private loaded = false;

		connectedCallback() {
			const rootMargin = this.dataset.rootMargin || '200px';

			this.observer = new IntersectionObserver(
				(entries) => {
					entries.forEach((entry) => {
						if (entry.isIntersecting && !this.loaded) {
							this.loadContent();
						}
					});
				},
				{ rootMargin },
			);

			this.observer.observe(this);
		}

		disconnectedCallback() {
			this.observer?.disconnect();
		}

		private loadContent() {
			this.loaded = true;
			const template = this.querySelector(
				'template[data-deferred-content]',
			) as HTMLTemplateElement;

			if (template) {
				const content = template.content.cloneNode(true);
				this.appendChild(content);
				this.classList.add('loaded');

				// Remove skeleton after transition completes
				setTimeout(() => {
					const skeleton = this.querySelector('.deferred-skeleton');
					skeleton?.remove();
					// Reset min-height after content is loaded
					this.style.minHeight = 'auto';
				}, 300);
			}

			this.observer?.disconnect();
		}
	}

	customElements.define('deferred-section', DeferredSection);
</script>
