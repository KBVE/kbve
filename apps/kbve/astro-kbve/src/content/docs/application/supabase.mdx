---
title: Supabase
description: A deep dive into Supabase, an open-source Firebase alternative powered by PostgreSQL.
sidebar:
  label: Supabase
  order: 410
tags:
  - supabase
  - postgres
  - database
  - deno
  - backend
unsplash: 1605902711622-cfb43c44367c
img: https://images.unsplash.com/photo-1605902711622-cfb43c44367c?fit=crop&w=1400&h=700&q=75
---


import {
  Aside,
  Steps,
  Card,
  CardGrid,
  Code,
  FileTree,
} from '@astrojs/starlight/components';

import { Giscus, Adsense } from '@kbve/astropad';

## User

### User Vault - Secrets

This is a quick section for setting up a quick proof of concept and for the demo, we will be doing a character ai inspired meme.
Full disclosure, this is just for fun and is not meant to be taken serious.

```sql

create table private.user_secrets (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  key text not null, -- user-facing label like "osrs_email" or "github_token"
  vault_key text not null, -- actual vault path, like "user/{user_id}/osrs/email"
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint unique_user_key unique (user_id, key)
);

alter table private.user_secrets enable row level security;
create policy "No access by default" on private.user_secrets
  for all using (false); 
revoke all on private.user_secrets from anon, authenticated, public;
grant all on private.user_secrets to service_role;

```

After setting up the `user_secrets`, we can move forward with the next step and that would be the `osrs` table.

```sql

create table private.user_osrs_accounts (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade,
  account_name text not null, -- user-facing label (not email or login)
  vault_email_key text not null,
  vault_password_key text not null,
  state text default 'offline' check (state in ('offline', 'active', 'banned', 'error')),
  world integer,
  p2p boolean default false,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),

  constraint unique_user_account_name unique (user_id, account_name)
);

alter table private.user_osrs_accounts enable row level security;

create policy "No access by default" on private.user_osrs_accounts
  for all using (false);

revoke all on private.user_osrs_accounts from anon, authenticated, public;
grant all on private.user_osrs_accounts to service_role;


```

Now we need to setup the function to handle our user secret and making sure that it gets saved into the vault.
The internal RPC call is just for the service role and we will create a public facing proxy rpc function that will handle more of the core.
Since we wont be touching the value, we can leave that the way it is, but the key should be sanitized to be just az09 and underscore.
Furthermore, we should also do a quick check to make sure that the uuid for the `p_user_id` is valid since we will delete these based upon that.

```sql

create or replace function private.set_user_secret_internal(
  p_user_id uuid,
  p_key text,
  p_value text
)
returns void
language plpgsql
security definer
set search_path = private, vault, public
as $function$
declare
  v_vault_key text;
begin
  -- Validate user ID exists
  if not exists (select 1 from auth.users where id = p_user_id) then
    raise exception 'Invalid user_id';
  end if;

  -- Validate key format
  if p_key !~ '^[a-z0-9_]{3,64}$' then
    raise exception 'Invalid key format. Must match /^[a-z0-9_]{3,64}$/';
  end if;

  -- Construct the vault key path
  v_vault_key := format('user/%s/%s', p_user_id, p_key);

  -- Insert or update the vault key mapping
  insert into private.user_secrets (user_id, key, vault_key)
  values (p_user_id, p_key, v_vault_key)
  on conflict (user_id, key) do update
    set vault_key = excluded.vault_key,
        updated_at = now();

  -- Store the secret in Vault
  perform vault.set_secret(v_vault_key, p_value);
end;
$function$;

-- Revoke all access to the function from everyone by default
revoke all on function private.set_user_secret_internal(uuid, text, text)
from public, anon, authenticated;

-- Grant execute only to service_role
grant execute on function private.set_user_secret_internal(uuid, text, text)
to service_role;

```

Now we want to make sure that the public facing authenticated user is calling this internal function through our proxy function.
Here is the public facing proxied function.

```sql

create or replace function public.set_user_secret(
  p_key text,
  p_value text
)
returns void
language plpgsql
security definer
set search_path = public, private
as $function$
declare
  v_user_id uuid := auth.uid();
begin
  if v_user_id is null then
    raise exception 'Not authenticated';
  end if;

  if p_key !~ '^[a-z0-9_]{3,64}$' then
    raise exception 'Invalid key format. Only lowercase a-z, 0-9, and underscores (3â€“64 characters) are allowed.';
  end if;


  -- Call internal secure vault setter
  perform private.set_user_secret_internal(v_user_id, p_key, p_value);
end;
$function$;

-- Revoke all access to the function from default/public roles
revoke all on function public.set_user_secret(text, text)
from public, anon;

-- Grant only to authenticated users
grant execute on function public.set_user_secret(text, text)
to authenticated;

```


### User Function - Register

This is our register function as a proof of concept, includes some additional things like CORS and refreshing the material view.

```ts

// deno-lint-ignore-file no-explicit-any
import { createClient } from "npm:@supabase/supabase-js@2";
import { z } from "npm:zod@3.22.4";
import "jsr:@supabase/functions-js/edge-runtime.d.ts";
const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
  "Access-Control-Allow-Headers": "apikey, X-Client-Info, Content-Type, Authorization, Accept, Accept-Language, X-Authorization",
  "Access-Control-Expose-Headers": "Content-Length, X-JSON"
};
Deno.serve(async (req)=>{
  if (req.method === "OPTIONS") {
    return new Response(null, {
      status: 204,
      headers: corsHeaders
    });
  }
  const supabaseAuth = createClient(Deno.env.get("SUPABASE_URL"), Deno.env.get("SUPABASE_ANON_KEY"), {
    global: {
      headers: {
        Authorization: req.headers.get("Authorization") ?? ""
      }
    }
  });
  const supabaseAdmin = createClient(Deno.env.get("SUPABASE_URL"), Deno.env.get("SUPABASE_SERVICE_ROLE_KEY"));
  const inputSchema = z.object({
    username: z.string().regex(/^[a-zA-Z0-9_-]{3,30}$/)
  });
  try {
    const body = await req.json();
    const parsed = inputSchema.parse(body);
    const { data: { user }, error: userError } = await supabaseAuth.auth.getUser();
    if (userError || !user) {
      return new Response(JSON.stringify({
        error: "Unauthorized"
      }), {
        status: 401,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    const { id: user_id } = user;
    const { error: rpcError } = await supabaseAdmin.rpc("create_user_context_proxy", {
      user_id,
      username: parsed.username,
      bio: "",
      avatar_ulid: null,
      role: null,
      level: 1,
      credits: 0,
      khash: 0
    });
    if (rpcError) {
      console.error("[create_user_context] RPC Error", rpcError);
      return new Response(JSON.stringify({
        error: rpcError.message
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    const { error: metaError } = await supabaseAdmin.auth.admin.updateUserById(user_id, {
      user_metadata: {
        username: parsed.username
      }
    });
    if (metaError) {
      console.error("[user_metadata] Failed to update:", metaError);
      return new Response(JSON.stringify({
        error: metaError.message
      }), {
        status: 500,
        headers: {
          ...corsHeaders,
          "Content-Type": "application/json"
        }
      });
    }
    supabaseAdmin.rpc("refresh_view", {
      p_view_name: "user_balances_view"
    }).then(({ error })=>{
      if (error) {
        console.error("[refresh_view] Failed to refresh view:", error.message);
      }
    });
    return new Response(JSON.stringify({
      success: true
    }), {
      status: 200,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  } catch (err) {
    console.error("[create_user_context] Parse/Error", err);
    return new Response(JSON.stringify({
      error: err?.message ?? "Unknown error"
    }), {
      status: 400,
      headers: {
        ...corsHeaders,
        "Content-Type": "application/json"
      }
    });
  }
});

```

### User Schema - Inventory - Hybrid

<Aside type="note">
The hybrid inventory system combines two complementary approaches to handle different types of game items efficiently:

1. **Stackable Items** (`inventory_stackable`): For items that can be grouped together (consumables, materials, currency)
2. **Instance Items** (`inventory_instances`): For unique items with individual properties (weapons with different durability, enchanted gear)
</Aside>

#### Inventory Design Philosophy

The dual-table approach optimizes both storage and query performance:

- **Stackable items** reduce database bloat by storing quantities instead of individual rows
- **Instance items** preserve unique characteristics and modification history
- **Unified querying** through views and functions provides a seamless developer experience

#### Inventory Key Features

**Security & Performance:**
- All tables use Row Level Security (RLS) with restrictive policies, i.e deny all but `service_role`
- Only the `service_role` has direct access to prevent unauthorized modifications, which will be used by the RPC.
- Indexed on `user_id` for fast lookups.
- UUID primary keys with automatic generation.

**Data Integrity:**
- Foreign key constraints ensure referential integrity with `auth.users`
- Check constraints prevent negative quantities.
- Unique constraints prevent duplicate stackable entries per user/item.
- JSONB metadata fields for flexible item properties, extendable to instance items later on.

**Scalability Considerations:**
- Stackable items table remains lean even with millions of users.
- Instance items can store complex metadata without affecting stackable performance.
- Partitioning strategies can be applied based on `user_id` for large datasets.

We want to keep track of the user inventory but with a couple checks in place, this is for items that are at the spaceship level.
This system will use a dual tracking system, one for the stackable and another for the instance.

```sql
create table private.inventory_stackable (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id)
    on delete cascade on update restrict,
  item_id text not null, -- ULID/SKU of item type
  quantity integer not null check (quantity >= 0),
  meta jsonb default '{}'::jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Unique constraint: 1 row per (user_id, item_id)
create unique index idx_unique_stackable_user_item on private.inventory_stackable(user_id, item_id);

-- Fast lookup
create index idx_stackable_user on private.inventory_stackable(user_id);

-- Enable and lock down RLS
alter table private.inventory_stackable enable row level security;

create policy "No access to stackable inventory" on private.inventory_stackable
  for all using (false);

create table private.inventory_instances (
  id uuid primary key default gen_random_uuid(),
  user_id uuid references auth.users(id)
    on delete cascade on update restrict,
  item_id text not null, -- ULID/SKU of item type
  meta jsonb default '{}'::jsonb, -- durability, modifiers, etc
  created_at timestamptz default now()
);

-- Fast lookup
create index idx_instances_user on private.inventory_instances(user_id);

-- Enable and lock down RLS
alter table private.inventory_instances enable row level security;

create policy "No access to inventory instances" on private.inventory_instances
  for all using (false);

-- Service Role Perms.

-- Grant all access to the service role
grant select, insert, update, delete on private.inventory_stackable to service_role;
grant select, insert, update, delete on private.inventory_instances to service_role;

-- If using sequences (not needed for UUIDs, but safe practice)
grant usage, select on all sequences in schema private to service_role;
```

## Admin

### Admin Schema

This is the schema that we will be using to install the admin panel.

```sql

-- Create the admin schema
create schema if not exists admin;

-- Revoke default PUBLIC access
revoke all on schema admin from public;

-- Revoke access to objects in the schema from anon/authenticated
revoke all on all tables in schema admin from anon, authenticated;
revoke all on all functions in schema admin from anon, authenticated;

-- Grant access to service_role
grant usage on schema admin to service_role;
grant select, insert, update, delete on all tables in schema admin to service_role;
grant execute on all functions in schema admin to service_role;

```

### Refresh Flags Table

The core table for refreshing the material views, allowing us to cache some of the future heavy reads.

```sql

-- Create the refresh_flags table in the admin schema
create table if not exists admin.refresh_flags (
  view_name text primary key,
  needs_refresh boolean default true,
  updated_at timestamptz default now()
);

-- Revoke all privileges on the table from public-facing roles
revoke all on table admin.refresh_flags from public;
revoke all on table admin.refresh_flags from anon;
revoke all on table admin.refresh_flags from authenticated;

-- Grant access only to the service role
grant select, insert, update, delete on table admin.refresh_flags to service_role;

-- Enable RLS explicitly
alter table admin.refresh_flags enable row level security;

-- (Optional) Create a RLS policy for service_role
create policy "Service can access all rows"
on admin.refresh_flags
for all
to service_role
using (true)
with check (true);
```

The next part will be to deploy the function to handle the flag shifts and refreshing the material views.

```sql

create or replace function admin.refresh_view(p_view_name text)
returns void
language plpgsql
security definer
set search_path = admin, public
as $$
begin
  -- Ensure the view exists in the public schema
  if not exists (
    select 1 from pg_matviews
    where schemaname = 'public' and matviewname = p_view_name
  ) then
    raise exception 'Invalid or unknown materialized view: %', p_view_name;
  end if;

  -- Only refresh if flagged
  if exists (
    select 1 from admin.refresh_flags
    where view_name = p_view_name and needs_refresh
  ) then

    -- Dynamically refresh the view safely
    execute format(
      'refresh materialized view concurrently public.%I',
      p_view_name
    );

    -- Reset the flag
    update admin.refresh_flags
    set needs_refresh = false,
        updated_at = now()
    where view_name = p_view_name;
  end if;
end;
$$;

-- Secure the function: prevent access from public/anon/authenticated
revoke execute on function admin.refresh_view(text) from public;
revoke execute on function admin.refresh_view(text) from anon;
revoke execute on function admin.refresh_view(text) from authenticated;

-- Allow only service role to call it
grant execute on function admin.refresh_view(text) to service_role;

```

Next, we want a proxy function so that it be easier to call from the edge workers.

```sql

create or replace function public.refresh_view(p_view_name text)
returns void
language plpgsql
security invoker
set search_path = public, admin
as $$
begin
  -- Step 1: Set the refresh flag
  insert into admin.refresh_flags (view_name, needs_refresh)
  values (p_view_name, true)
  on conflict (view_name)
  do update set needs_refresh = true, updated_at = now();

  -- Step 2: Call the internal secure function
  perform admin.refresh_view(p_view_name);
end;
$$;

-- Secure the function
revoke execute on function public.refresh_view(text) from public;
revoke execute on function public.refresh_view(text) from anon;
revoke execute on function public.refresh_view(text) from authenticated;
grant execute on function public.refresh_view(text) to service_role;

```

## Utility


### Generate ULID Functions

```sql

create or replace function gen_ulid()
returns text
language plpgsql
set search_path = public, extensions
as $$
declare
  time_part text := to_hex((extract(epoch from clock_timestamp()) * 1000)::bigint);
  rand_part text := encode(extensions.gen_random_bytes(10), 'hex');
begin
  return lpad(time_part, 12, '0') || rand_part;
end;
$$;

```