---
title: Docker
description: |
    A hybrid-source application designed to deploy nested-virtual machines that are containerized applications.
sidebar:
    label: Docker
    order: 100
unsplash: 1605745341112-85968b19335b
img: https://images.unsplash.com/photo-1605745341112-85968b19335b?fit=crop&w=1400&h=700&q=75
---

import {
	Aside,
	Steps,
	Card,
	CardGrid,
	Code,
	FileTree,
} from '@astrojs/starlight/components';

import { Giscus, Adsense } from '@kbve/astropad';


## Tools

<Aside type="danger" title="Docker Tool Inbound">

This is just a short place holder for a docker tool that I am making!

</Aside>

<Adsense />

## Information

In one sentence, we can describe docker as a hybrid-source application designed to deploy nested-virtual machines that are containerized applications.
Docker is a powerful tool that can help you develop, deploy, and manage your applications.
The Docker build process lets you package your application and all its dependencies into a single image.
This image can then be run on any machine that has Docker installed, regardless of the underlying operating system.
Think of the image as a virtual cd or iso, it has everything needed to run your software wrapped into a single fancy file.
Finally the image/container makes it easy to deploy your application to any environment, whether it's a local development machine, a cloud server, or a production environment.
It's easy to get started with Docker, and you can be up and running in just a few minutes to about a hour if you are a bit noobie.
Remember that containers are lightweight, isolated environments that make it easy to deploy your applications.
They're also portable, so you can run them on any machine that has Docker installed.
So docker takes your source code, wraps it all into an image, then runs the image in a virtual machine aka container.
Also, in this documentation, we will include more additional tips, such as security and optimization, for your docker adventure.

---

## Cheatsheet

This is a quick cheetsheet for Docker, everyone comes back to these sheet for when they run into future problems or forget a certain command.
It is not important to understand this cheetsheet until you have a couple sessions of docker delopyment under your belt, so if you are a newbie, do not freak out!

-   Basic CLI (Command-line interface)
    -   Container Management Commands
        -   `docker create $image [-command]` - Create a Docker Container based upon the image String; -command for additional flags.
        -   `docker run $image [-command]` - Combines the command `create` and `start`.
        -   `docker start $cont` - Start the specific docker container (defined via cont String).
        -   `docker stop $cont` - Shutdown the specific docker container (defined via cont String).
        -   `docker kill $cont` - Kill the specific docker container (defined via cont String).
        -   `docker restart $cont` - Restart the specific docker container (defined via cont String).
        -   `docker pause $cont` - Pause the specific docker container (defined via cont String).
        -   `docker rm $cont` - Remove the specific docker container (defined via cont String).
    -   Inspecting Containers
        -   `docker ps` - List running docker containers.
        -   `docker ps -a` - List all docker containers, including docker containers that are paused / off.
        -   `docker logs $cont` - Display the specific docker container output (defined via cont String)
        -   `docker top $cont [-ps]` - Display the processes running inside the specific docker container (defined via cont String).
        -   `docker diff $cont` - Show the differences, within the modified files, between the specific container and the source image (defined via cont String).
        -   `docker inspect $cont` - Show information about the specific docker container (defined via cont String).
            -   Output of the data will default to `json`.
    -   Interacting with Containers
        -   `docker attach $cont` - Attach to the specific docker container and see the _stdin, stdout, stderr_ (defined via cont String)
        -   `docker cp $cont:$path $hostpath` - Copy files from the docker container.
        -   `docker cp $hostpath $cont:$path` - Copy files into the docker container.
        -   `docker export $cont` - Export the data of the specific docker container.
            -   Output of the data will default to a `tar` archive.
        -   `docker exec $cont $command` - Runs the $command inside of the specific docker container (defined via cont String).
        -   `docker wait $cont` - Waits until the specific docker container terminates and returns an exit code.
        -   `docker commit $cont $image` - Commits a new docker image via a snapshot of the specific docker container.
    -   Network
        -   `docker network create $netname` - Create a network with the variable $netname.
    -   Docker Compose
        -   `docker compose start` - Start a YAML configuration for a docker container.
        -   `docker compose stop` - Stop the most recent composed docker container.
        -   `docker compose pause` - Pause the most recent composed docker container.
        -   `docker compose unpause` - Unpause the most rencent composed docker container.
        -   `docker compose ps` - List the current docker containers
        -   `docker compose up -f $compose.yml [$command]` - Start and run a YAML configuration for a docker container.
        -   `docker compose down` - Down a composed docker container.
    -   Docker Swarm
        -   `docker swarm init` - The docker container will become a manager node within the initialized container.
            -   Upon the initialization instance, the container will provide a token for other worker/manager nodes to join.
        -   `docker swarm join --token $token $ip` - Docker container will join the swarm as a worker; token string should be obtained by init and the `$ip` should be IP Address and port.
            -   `$ip` will be given as `$$ipaddress:$$port` , where the substring `$$ipaddress` is the IPv4address or IPv6address and the substring `$$port` is the open port on that `$$ipaddress`.
    -   Docker Prune / Clean up
        -   `docker system prune` - The docker system will clean up any dead objects, such as containers, networks, ect..
            -   `docker system prune -a` - Incase you need to do a deep clean within the docker node.

Full Table of Commands:

### Docker CLI Commands Cheatsheet

| Command                                    | Description                                                                                 |
| ------------------------------------------ | ------------------------------------------------------------------------------------------- |
| `docker --version`                         | Show the Docker version information.                                                        |
| `docker info`                              | Display system-wide information about Docker.                                               |
| `docker login`                             | Log in to a Docker registry.                                                                |
| `docker logout`                            | Log out from a Docker registry.                                                             |
| `docker pull <image>`                      | Download an image from a Docker registry.                                                   |
| `docker push <image>`                      | Upload an image to a Docker registry.                                                       |
| `docker build <path>`                      | Build an image from a Dockerfile.                                                           |
| `docker run <image>`                       | Run a command in a new container.                                                           |
| `docker start <container>`                 | Start one or more stopped containers.                                                       |
| `docker stop <container>`                  | Stop one or more running containers.                                                        |
| `docker restart <container>`               | Restart one or more containers.                                                             |
| `docker rm <container>`                    | Remove one or more containers.                                                              |
| `docker rmi <image>`                       | Remove one or more images.                                                                  |
| `docker ps`                                | List running containers.                                                                    |
| `docker ps -a`                             | List all containers, including stopped ones.                                                |
| `docker images`                            | List images.                                                                                |
| `docker inspect <container>`               | Display detailed information on one or more containers or images.                           |
| `docker logs <container>`                  | Fetch the logs of a container.                                                              |
| `docker exec <container> <command>`        | Run a command in a running container.                                                       |
| `docker cp <container>:<path> <host path>` | Copy files/folders between a container and the local filesystem.                            |
| `docker commit <container> <new_image>`    | Create a new image from a container's changes.                                              |
| `docker tag <source_image> <target_image>` | Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE.                                      |
| `docker network ls`                        | List all networks.                                                                          |
| `docker network create <name>`             | Create a new network.                                                                       |
| `docker network rm <network>`              | Remove one or more networks.                                                                |
| `docker volume ls`                         | List volumes.                                                                               |
| `docker volume create <name>`              | Create a new volume.                                                                        |
| `docker volume rm <volume>`                | Remove one or more volumes.                                                                 |
| `docker top <container>`                   | Display the running processes of a container.                                               |
| `docker stats`                             | Display a live stream of container(s) resource usage statistics.                            |
| `docker pause <container>`                 | Pause all processes within one or more containers.                                          |
| `docker unpause <container>`               | Unpause all processes within one or more containers.                                        |
| `docker update <container>`                | Update configuration of one or more containers.                                             |
| `docker wait <container>`                  | Block until one or more containers stop, then print their exit codes.                       |
| `docker attach <container>`                | Attach local standard input, output, and error streams to a running container.              |
| `docker kill <container>`                  | Kill one or more running containers.                                                        |
| `docker rename <old_name> <new_name>`      | Rename a container.                                                                         |
| `docker system prune`                      | Remove unused data.                                                                         |
| `docker container prune`                   | Remove all stopped containers.                                                              |
| `docker image prune`                       | Remove unused images.                                                                       |
| `docker volume prune`                      | Remove all unused volumes.                                                                  |
| `docker network prune`                     | Remove all unused networks.                                                                 |
| `docker system df`                         | Show docker disk usage.                                                                     |
| `docker image save <image> -o <file>`      | Save one or more images to a tar archive (streamed to STDOUT by default).                   |
| `docker image load -i <file>`              | Load an image from a tar archive or STDIN.                                                  |
| `docker history <image>`                   | Show the history of an image.                                                               |
| `docker export <container> -o <file>`      | Export a container’s filesystem as a tar archive.                                           |
| `docker import <file> <new_image>`         | Import the contents from a tarball to create a filesystem image.                            |
| `docker buildx create`                     | Create a new builder instance.                                                              |
| `docker buildx inspect`                    | Show information about a builder instance.                                                  |
| `docker buildx use <builder>`              | Set the current builder instance.                                                           |
| `docker buildx build`                      | Start a new build using the buildx builder.                                                 |
| `docker-compose up`                        | Build, create, start, and attach to containers for a service defined in docker-compose.yml. |
| `docker-compose down`                      | Stop and remove containers, networks, images, and volumes defined in docker-compose.yml.    |
| `docker-compose logs`                      | View output from containers.                                                                |
| `docker-compose ps`                        | List containers.                                                                            |
| `docker-compose exec`                      | Execute a command in a running container.                                                   |
| `docker-compose stop`                      | Stop services.                                                                              |
| `docker-compose start`                     | Start services.                                                                             |
| `docker-compose restart`                   | Restart services.                                                                           |
| `docker-compose pull`                      | Pull service images.                                                                        |
| `docker-compose build`                     | Build or rebuild services.                                                                  |
| `docker-compose rm`                        | Remove stopped service containers.                                                          |
| `docker-compose up -d`                     | Start containers in detached mode.                                                          |

Swarm Cheatsheet Table for Swarm Mode

| Command                                                                  | Description                                        |
| ------------------------------------------------------------------------ | -------------------------------------------------- |
| `docker swarm init`                                                      | Initialize a swarm.                                |
| `docker swarm join --token <token> <manager_ip>`                         | Join a swarm as a node.                            |
| `docker swarm leave`                                                     | Leave a swarm.                                     |
| `docker swarm update`                                                    | Update the swarm configuration.                    |
| `docker node ls`                                                         | List nodes in the swarm.                           |
| `docker node inspect <node>`                                             | Display detailed information on one or more nodes. |
| `docker node update --availability <active or paused or drained> <node>` | Update a node's availability.                      |
| `docker node promote <node>`                                             | Promote a node to a manager.                       |
| `docker node demote <node>`                                              | Demote a manager node to a worker.                 |
| `docker service create --name <service_name> <image>`                    | Create a new service.                              |
| `docker service ls`                                                      | List services.                                     |
| `docker service inspect <service>`                                       | Display detailed information about a service.      |
| `docker service update <service>`                                        | Update a service.                                  |
| `docker service scale <service>=<replicas>`                              | Scale a service to a specified number of replicas. |
| `docker service rm <service>`                                            | Remove a service.                                  |
| `docker service logs <service>`                                          | Fetch the logs of a service.                       |
| `docker service ps <service>`                                            | List the tasks of a service.                       |
| `docker stack deploy -c <compose-file> <stack>`                          | Deploy a new stack or update an existing stack.    |
| `docker stack ls`                                                        | List stacks.                                       |
| `docker stack services <stack>`                                          | List the services in a stack.                      |
| `docker stack ps <stack>`                                                | List the tasks in a stack.                         |
| `docker stack rm <stack>`                                                | Remove a stack.                                    |
| `docker config create <config_name> <file>`                              | Create a new config from a file.                   |
| `docker config ls`                                                       | List configs.                                      |
| `docker config inspect <config>`                                         | Display detailed information about a config.       |
| `docker config rm <config>`                                              | Remove one or more configs.                        |
| `docker secret create <secret_name> <file>`                              | Create a new secret from a file.                   |
| `docker secret ls`                                                       | List secrets.                                      |
| `docker secret inspect <secret>`                                         | Display detailed information about a secret.       |
| `docker secret rm <secret>`                                              | Remove one or more secrets.                        |
| `docker stack deploy --with-registry-auth -c <compose-file> <stack>`     | Deploy a stack using registry authentication.      |
| `docker service rollback <service>`                                      | Revert a service to its previous version.          |
| `docker service ps <service>`                                            | List the tasks of a service.                       |
| `docker node ps <node>`                                                  | List the tasks running on a node.                  |
| `docker swarm unlock`                                                    | Unlock a locked manager.                           |
| `docker swarm unlock-key`                                                | Manage the unlock key for a swarm.                 |

---

## DockerFile

A Dockerfile is a crucial component in building Docker images, serving as a simple script that specifies the base image and a set of instructions to assemble the final image.
Acting as an isolated operating system for specific applications, a Dockerfile ensures all necessary libraries and dependencies are pre-installed and pre-built.
This document aims to provide a comprehensive guide for all Docker needs, catering to both new users and professionals, by covering essential concepts and advanced techniques for effective Docker usage.

<Aside type="tip" title="Understanding the Dockerfile">
	The Dockerfile is a simple document that assembles the Docker image using a
	specific base and a set of commands. The concept is that the Docker image
	acts as an isolated operating system for the specific application, with all
	necessary libraries pre-installed and pre-built.
</Aside>

### FROM

The `FROM` instruction in a Dockerfile specifies the base image for the Docker image being built.
There are four generic ways to use `FROM`:

| Method                        | Description                                                                                                                                                                                                                                                                                                     |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1. `FROM {image}`             | The `{image}` represents the base image title or reference, such as `ubuntu` or `alpine`.                                                                                                                                                                                                                       |
| 2. `FROM {image}:{tag}`       | The `{tag}` specifies a particular version of the image, which can be useful for ensuring consistency. For example, `node:16` or `node:16-bullseye`.                                                                                                                                                            |
| 3. `FROM {image}@{digest}`    | The `{digest}` is the `sha-256` hash used to verify the integrity of the image. It ensures that the image has not been altered and is exactly as expected.                                                                                                                                                      |
| 4. `FROM {repository}#{hash}` | The `{repository}#{hash}` allows specifying a base image directly from a GitHub repository using a specific commit hash. This method is particularly useful when the base image is hosted in a repository and the exact state of the code is needed. For example, `FROM github.com/kbve/repo#abcdef1234567890`. |

Using these methods, the `FROM` instruction provides flexibility and precision in defining the base image, ensuring that the Docker image is built upon a reliable and verified foundation.

### MAINTAINER

<Aside type="caution" title="Caution: Deprecated Instruction">
	The **MAINTAINER** instruction has been deprecated. For current best
	practices, refer to the **LABEL** section.
</Aside>

The `MAINTAINER` instruction in a Dockerfile specifies the author or maintainer of the Docker image.
Although deprecated in favor of using labels, it is still useful to know for legacy Dockerfiles.
The `MAINTAINER` instruction provides metadata about the person or organization responsible for maintaining the image.

| Option                              | Description                                                                                                                  |
| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| `MAINTAINER {name}`                 | Specifies the name of the maintainer. For example, `MAINTAINER h0ly Byte`.                                                   |
| `MAINTAINER {name} <email>`         | Provides both the name and email of the maintainer. For example, `MAINTAINER h0ly Byte <no.reply@kbve.com>`.                 |
| `LABEL maintainer="{name} <email>"` | The recommended way to specify the maintainer using labels. For example, `LABEL maintainer="h0ly Byte <no.reply@kbve.com>"`. |

This table illustrates the different ways to specify the maintainer information, emphasizing the shift towards using labels for better metadata management.

### RUN

The `RUN` instruction in a Dockerfile is used to execute commands within the container during the image build process.
It allows for the installation of software packages, modification of files, and other tasks required to set up the environment for the application.

| Method                                   | Description                                                                                                                                                      |
| ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `RUN {command}`                          | Executes a command in a new layer on top of the current image and commits the results. For example, `RUN apt-get update && apt-get install -y nginx`.            |
| `RUN ["executable", "param1", "param2"]` | Uses the exec form to run the command. This is typically preferred for commands that include arguments. For example, `RUN ["apt-get", "install", "-y", "curl"]`. |

The table above illustrates the different ways to use the `RUN` instruction to execute commands during the build process, either using the shell form or the exec form, depending on the requirements.

<Aside type="tip" title="RUN vs. CMD">
	The **RUN** and **CMD** instructions in a Dockerfile serve different
	purposes. **RUN** executes commands during the build process to set up the
	image, such as installing software or setting environment variables,
	creating a new image layer each time it's used. In contrast, **CMD**
	specifies the default command to run when the container starts, determining
	the container's behavior at runtime. Use **RUN** for build-time
	configurations and **CMD** for runtime configurations to ensure a clear and
	effective Dockerfile.
</Aside>

### CMD

The `CMD` instruction in a Dockerfile specifies the default command to run when a container is started.
Unlike `RUN`, which is used during the build process, `CMD` is executed when the container runs.
If multiple `CMD` instructions are specified, only the last one takes effect.

| Method                                 | Description                                                                                                                                       |
| -------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| `CMD ["executable","param1","param2"]` | Specifies the command to run in exec form. For example, `CMD ["nginx", "-g", "daemon off;"]`. This form is preferred for commands with arguments. |
| `CMD ["param1","param2"]`              | Provides default parameters for the `ENTRYPOINT` instruction. For example, `CMD ["-d"]` when combined with `ENTRYPOINT ["nginx"]`.                |
| `CMD command param1 param2`            | Specifies the command to run in shell form. For example, `CMD echo "Hello, World!"`. This form runs in a shell (`/bin/sh -c`).                    |

The reference CMD table above explains the different ways to use the `CMD` instruction, either by specifying the command in exec form, providing default parameters for an `ENTRYPOINT`, or using shell form to run commands.

Sure! Here are the detailed sections with markdown tables for each of the requested Dockerfile instructions:

### LABEL

The `LABEL` instruction in a Dockerfile is used to add metadata to the image.
Labels can provide information such as the maintainer's name, version, description, and other key-value pairs.

| Method                          | Description                                                                                |
| ------------------------------- | ------------------------------------------------------------------------------------------ |
| `LABEL key=value`               | Adds a label with a key-value pair. For example, `LABEL version="1.0"`.                    |
| `LABEL key1=value1 key2=value2` | Adds multiple labels at once. For example, `LABEL maintainer="John Doe" version="1.0"`.    |
| `LABEL key="value with spaces"` | Adds a label with a value that includes spaces. For example, `LABEL description="My App"`. |

### ENV

The `ENV` instruction in a Dockerfile sets environment variables, which can be used by the running container.
Environment variables set using `ENV` persist throughout the lifetime of the container.

| Method                        | Description                                                                                           |
| ----------------------------- | ----------------------------------------------------------------------------------------------------- |
| `ENV key=value`               | Sets an environment variable. For example, `ENV PATH=/usr/local/nginx/bin:$PATH`.                     |
| `ENV key value`               | Sets an environment variable using key and value as separate arguments. For example, `ENV PORT 8080`. |
| `ENV key1=value1 key2=value2` | Sets multiple environment variables at once. For example, `ENV LANG=C.UTF-8 LC_ALL=C.UTF-8`.          |

<Aside type="tip" title="COPY vs. ADD">
	While both **COPY** and **ADD** instructions in a Dockerfile are used to
	copy files from the host to the container, there are key differences.
	**COPY** simply copies local files and directories, ensuring a
	straightforward and predictable behavior. **ADD**, on the other hand, can
	also handle remote URLs and automatically extract compressed files (e.g.,
	tar archives). For most use cases, **COPY** is preferred for its clarity and
	simplicity, reserving `ADD` for scenarios where its additional features are
	necessary.
</Aside>

### ADD

The `ADD` instruction in a Dockerfile copies files, directories, or remote URLs from the source to the destination in the container.
Unlike `COPY`, `ADD` can also handle remote URLs and extract tar archives.

| Method                              | Description                                                                                                                 |
| ----------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| `ADD src dest`                      | Copies files or directories from `src` to `dest`. For example, `ADD myapp.tar.gz /app`.                                     |
| `ADD ["src", "dest"]`               | Copies files or directories from `src` to `dest` using the exec form. For example, `ADD ["app.conf", "/etc/app.conf"]`.     |
| `ADD http://example.com/file /file` | Downloads a file from a URL and copies it to the container. For example, `ADD http://example.com/file.tar.gz /file.tar.gz`. |

### COPY

The `COPY` instruction in a Dockerfile copies files and directories from the source on the host to the destination path in the container.
Unlike `ADD`, `COPY` only supports copying local files and directories.

| Method                 | Description                                                                                                              |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `COPY src dest`        | Copies files or directories from `src` to `dest`. For example, `COPY myapp /app`.                                        |
| `COPY ["src", "dest"]` | Copies files or directories from `src` to `dest` using the exec form. For example, `COPY ["app.conf", "/etc/app.conf"]`. |
| `COPY src/ dest/`      | Copies contents of a directory from `src` to `dest`. For example, `COPY src/ /app/`.                                     |

### ENTRYPOINT

The `ENTRYPOINT` instruction in a Dockerfile specifies the command that will always be executed when the container starts.
It allows configuring a container to run as an executable.

| Method                                          | Description                                                                                                                                              |
| ----------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `ENTRYPOINT ["executable", "param1", "param2"]` | Specifies the command to run in exec form. For example, `ENTRYPOINT ["nginx", "-g", "daemon off;"]`. This form is preferred for commands with arguments. |
| `ENTRYPOINT command param1 param2`              | Specifies the command to run in shell form. For example, `ENTRYPOINT /bin/sh -c "echo Hello"`. This form runs in a shell (`/bin/sh -c`).                 |

### VOLUME

The `VOLUME` instruction in a Dockerfile creates a mount point with a specified path and marks it as holding externally mounted volumes from native host or other containers.
It is used to persist data generated by and used by the Docker container.

| Method                      | Description                                                                                  |
| --------------------------- | -------------------------------------------------------------------------------------------- |
| `VOLUME ["/data"]`          | Creates a volume at the specified path. For example, `VOLUME ["/data"]`.                     |
| `VOLUME /data`              | Creates a volume at the specified path using the string form. For example, `VOLUME /data`.   |
| `VOLUME ["path1", "path2"]` | Creates multiple volumes at the specified paths. For example, `VOLUME ["/data", "/config"]`. |

### USER

The `USER` instruction in a Dockerfile sets the user name or UID (and optionally the group name or GID) to use when running the image and for any `RUN`, `CMD`, and `ENTRYPOINT` instructions that follow.

| Method            | Description                                                                                    |
| ----------------- | ---------------------------------------------------------------------------------------------- |
| `USER user`       | Sets the user to run the container as. For example, `USER nginx`.                              |
| `USER user:group` | Sets the user and group to run the container as. For example, `USER nginx:nginx`.              |
| `USER uid`        | Sets the user by UID to run the container as. For example, `USER 1001`.                        |
| `USER uid:gid`    | Sets the user and group by UID and GID to run the container as. For example, `USER 1001:1001`. |

### WORKDIR

The `WORKDIR` instruction in a Dockerfile sets the working directory for any `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, and `ADD` instructions that follow.
If the directory does not exist, it will be created.

| Method                     | Description                                                                          |
| -------------------------- | ------------------------------------------------------------------------------------ |
| `WORKDIR /path/to/workdir` | Sets the working directory for subsequent instructions. For example, `WORKDIR /app`. |
| `WORKDIR /path/to/workdir` | Creates the directory if it does not exist. For example, `WORKDIR /usr/src/app`.     |

### ARG

The `ARG` instruction in a Dockerfile defines a variable that users can pass at build-time to the builder with the `docker build` command.
These variables can be used in the Dockerfile to customize the build process.

| Method                          | Description                                                                                |
| ------------------------------- | ------------------------------------------------------------------------------------------ |
| `ARG name`                      | Defines a build-time variable. For example, `ARG VERSION`.                                 |
| `ARG name=default`              | Defines a build-time variable with a default value. For example, `ARG VERSION=latest`.     |
| `ARG name1=value1 name2=value2` | Defines multiple build-time variables at once. For example, `ARG VERSION=1.0 BASE=alpine`. |

### ONBUILD

The `ONBUILD` instruction in a Dockerfile adds a trigger instruction to the image that will be executed when the image is used as a base for another build.
It is useful for images that are intended to be used as a base for other images.

| Method                 | Description                                                                                                     |
| ---------------------- | --------------------------------------------------------------------------------------------------------------- |
| `ONBUILD INSTRUCTION`  | Adds a trigger instruction to be executed when the image is used as a base. For example, `ONBUILD COPY . /app`. |
| `ONBUILD RUN command`  | Adds a trigger instruction to run a command. For example, `ONBUILD RUN echo "Building child image"`.            |
| `ONBUILD ADD src dest` | Adds a trigger instruction to copy files. For example, `ONBUILD ADD . /src`.                                    |

### STOPSIGNAL

The `STOPSIGNAL` instruction in a Dockerfile sets the system call signal that is used to stop the container or application.
The default setting sends `SIGTERM` and waits for 10 seconds to allow for a graceful shutdown before sending `SIGKILL`.

| Method              | Description                                                                                       |
| ------------------- | ------------------------------------------------------------------------------------------------- |
| `STOPSIGNAL signal` | Sets the system call signal to stop the container. For example, `STOPSIGNAL SIGINT`.              |
| `STOPSIGNAL signal` | The default setting is `SIGTERM`, with a 10-second wait for a graceful shutdown before `SIGKILL`. |

### HEALTHCHECK

The `HEALTHCHECK` instruction in a Dockerfile provides a way to determine the health status of a container, informing the swarm or manager about the general status of the running application.
The two primary statuses are `healthy` and `unhealthy`.

| Method                                           | Description                                                                                                                                    |
| ------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- | --- | -------- |
| `HEALTHCHECK [options] CMD command`              | Defines a command to test the container's health. For example, `HEALTHCHECK CMD curl -f http://localhost/                                      |     | exit 1`. |
| `HEALTHCHECK NONE`                               | Disables any health checks inherited from the base image.                                                                                      |
| `HEALTHCHECK --interval=30s --timeout=10s \ CMD` | Specifies options such as interval, timeout, and retries. For example, `HEALTHCHECK --interval=30s --timeout=10s CMD curl -f http://localhost/ |     | exit 1`. |

### SHELL

The `SHELL` instruction allows changing the default shell used for the `RUN` instruction.

| Method                          | Description                                                                                                   |
| ------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| `SHELL ["executable", "param"]` | Changes the default shell for subsequent `RUN` instructions. For example, `SHELL ["powershell", "-Command"]`. |

### EXPOSE

The `EXPOSE` instruction informs Docker that the container listens on the specified network ports at runtime.
This is a form of documentation and does not actually publish the port.

| Method                 | Description                                                                    |
| ---------------------- | ------------------------------------------------------------------------------ |
| `EXPOSE port`          | Specifies a port to be listened to by the container. For example, `EXPOSE 80`. |
| `EXPOSE port/protocol` | Specifies a port and protocol (TCP/UDP). For example, `EXPOSE 80/tcp`.         |

---

## GPU

### Windows

GPU pass-through on Windows is still in the experimental stage, but here are some quick ways to get started with the basics.
This guide assumes you have WSL (Windows Subsystem for Linux) installed.
If you need assistance with WSL, refer to [WSL Help](/application/wsl/).

#### Nvidia

-   Install the latest CUDA driver libraries from the official Nvidia website. Visit [Nvidia CUDA](https://developer.nvidia.com/cuda-downloads) for downloads and installation instructions.
-   Ensure you have installed the latest core libraries as per the provided instructions.

---

## Setup

Docker is the future of application development because of how fast, easy and portable the software is.
In this section of the document, we will focus on setting up the application on various operating systems, including linux, windows and mac.
With Docker, you can build, deploy, and manage your applications in a fraction of the time it would take with traditional methods.
If you're not using Docker, you're missing out.
So what are you waiting for homie!?
Let us begin the setup quest for Docker today!

This section breaks down the various areas of installing `docker`.
To install Docker, simply visit the Docker website and download the installer for your operating system.

Here is a quick [google sheet](https://docs.google.com/spreadsheets/d/1ZT8m4gpvh6xhHYIi4Ui19uHcMpymwFXpTAvd3EcgSm4/edit?gid=0#gid=0) that breaks down the different docker desktop clients for each operating systems.
This sheet has been up-to-date since late 2024 and they include about 20 different clients for MacOS, Windows and Linux.

### Linux

The operating sysetm that we perfer is `Ubuntu` and here is a quick and brief tutorial:

-   Ubuntu Installation Guide
    -   Core Pre-Installation
        -   `lsb_release -a` - Unix command to see the version of Ubuntu that we are running.
        -   According to Docker (2022), these are the 64-bit versions of Ubuntu that they support.
            -   `Ubuntu Jammy 22.04 (LTS)`
            -   `Ubuntu Impish 21.10`
            -   `Ubuntu Focal 20.04 (LTS)`
            -   `Ubuntu Bionic 18.04 (LTS)`
        -   Hint: We like to make sure everything is updated and upgraded before we start. So run `sudo apt-get update` and then `sudo apt-get upgrade`.
        -   Now there are libraries that you will need before installing docker.
    -   Post Installation
        -   Adding Docker Compose through `sudo apt-get install docker-compose-plugin`, you may need to update before installing.
        -   Verifying the installation through `docker compose version` and if there are any issues, visit our support.

### Windows

Before we being our journey on setting up `Docker` onto Windows, you will have to make sure that WSL is installed and ready.
Furthermore, you may need to enable the Hyper-V through your bios.

The best way to setup `Docker` is by installing the engine through `Choco` because it will help keep the engine up to date.

---

## BuildX

Buildx is an advanced Docker CLI plugin designed to enhance the container building experience by providing extended capabilities powered by BuildKit.
Leveraging multi-node and multi-platform builds, Buildx facilitates the creation of containers optimized for diverse architectures, such as ARM and x86.
The plugin supports cache export and import features, improving build efficiency and speeding up subsequent builds.
Additionally, Buildx integrates seamlessly with Docker, allowing users to manage build environments with ease.
The flexibility and power of Buildx make it an essential tool for developers seeking to streamline their containerization workflows and deploy applications across various environments.

<Aside type="tip" title="Tip: Maximize Build Efficiency with Caching">
	Take advantage of Buildx's cache export and import features to significantly
	speed up your builds. By reusing previously built layers, cache can minimize
	build times and reduce redundant processing. Ensure to set up cache
	effectively to optimize development workflows.
</Aside>

<Steps>

0. **Prerequisites**:

    Make sure Docker is installed on your system.
    If you need to install Docker, follow this [Docker installation guide](/application/docker/#setup).

1. **Verify Docker Installation**:

    First, check if Docker is installed by running the following command in your terminal:

    ```shell
    docker --version
    ```

    You should see output similar to:

    ```
    Docker version 20.10.7, build f0df350
    ```

2. **Check for Buildx in the Apt List**:

    Before installing Buildx, let's check if it is available in the apt package list. Run the following command:

    ```shell
    apt-cache search docker-buildx
    ```

    If Buildx is available, you should see an output similar to:

    ```
    docker-buildx - Docker CLI plugin for extended build capabilities with BuildKit
    ```

3. **Install Buildx (if available in apt)**:

    If Buildx is available in the apt list, you can install it using:

    ```shell
    sudo apt-get install docker-buildx
    ```

    Verify the installation by running:

    ```shell
    docker buildx version
    ```

    You should see output indicating the version of Buildx installed.

    An example of this output would be like this:

    ```
    github.com/docker/buildx 0.11.2 0.11.2-0ubuntu1^22.04.2
    ```

4. **Add Buildx (if not available in apt)**:

    <Aside>This is only if Step 3 was not an option.</Aside>

    If Buildx is not available in the apt package list, you can add it manually. Follow these steps:

    1. **Download the Buildx Binary**:

        Download the latest Buildx release from GitHub:

        ```sh
        mkdir -p ~/.docker/cli-plugins/
        curl -Lo ~/.docker/cli-plugins/docker-buildx https://github.com/docker/buildx/releases/latest/download/buildx-v0.10.0.linux-amd64
        ```

    2. **Make the Binary Executable**:

        Make the downloaded binary executable:

        ```sh
        chmod +x ~/.docker/cli-plugins/docker-buildx
        ```

    3. **Verify the Installation**:

        Check the Buildx version to ensure it was installed correctly:

        ```sh
        docker buildx version
        ```

        You should see output indicating the version of Buildx installed.

5. **Create and Use a New Builder Instance**:

    Create a new builder instance and switch to it:

    ```sh
    docker buildx create --name mybuilder --use
    ```

    You can verify that the new builder instance is being used by running:

    ```sh
    docker buildx inspect --bootstrap
    ```

6. **Build and Push Multi-Platform Images**:

    With Buildx, you can now build and push multi-platform images. For example:

    ```sh
    docker buildx build --platform linux/amd64,linux/arm64 -t username/repository:tag . --push
    ```

    Congratulations! You have successfully set up Docker Buildx on your system.

</Steps>

---

## WatchTower

WatchTower is a powerful utility designed to automatically update running Docker containers whenever new images are pushed to a repository.
Ensuring that applications are always running the latest version, WatchTower reduces manual intervention and minimizes downtime.
By continuously monitoring specified Docker containers, WatchTower detects updates, gracefully stops the container, pulls the latest image, and restarts the container with the new version.
Maintaining a smooth and efficient deployment pipeline, WatchTower is especially beneficial in environments where applications frequently update.

In addition to its core functionality, WatchTower can send notifications about the status of container updates.
Notifications can be sent to various channels such as email, Slack, or other messaging services, keeping teams informed about the update process.
This feature is particularly useful for maintaining transparency and ensuring that stakeholders are aware of the changes happening within the containerized environment.

To enable WatchTower notifications, set the appropriate environmental variables in the command line. For example:

```shell
docker run -d \
  --name watchtower \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -e WATCHTOWER_NOTIFICATIONS=email \
  -e WATCHTOWER_NOTIFICATION_EMAIL_FROM=fromaddress@gmail.com \
  -e WATCHTOWER_NOTIFICATION_EMAIL_TO=toaddress@gmail.com \
  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER=smtp.gmail.com \
  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PORT=587 \
  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_USER=fromaddress@gmail.com \
  -e WATCHTOWER_NOTIFICATION_EMAIL_SERVER_PASSWORD=app_password \
  -e WATCHTOWER_NOTIFICATION_EMAIL_DELAY=2 \
  containrrr/watchtower
```

This command configures WatchTower to send email notifications regarding the status of container updates.
Adjust the variables to suit the desired notification method and settings.
By utilizing WatchTower and its notification features, administrators can ensure that their Docker environments remain up-to-date and secure with minimal effort.

---

## Scripts

Shell or Bash scripts are powerful tools for automating Docker workflows. 
These scripts allow you to string together multiple Docker commands into a single executable file, which can simplify and streamline complex operations. 
or example, the script below demonstrates a series of Docker commands combined to build an image from the current directory, stop and remove a running container, and then run a new container with specific configurations. 
This script builds the Docker image with the tag `myapp`, stops any running container named `myapp_container`, removes it, and finally starts a new container named `myapp_container` in detached mode with specified ports and shared memory size.

**Build & Deploy**

```shell
docker build . -t myapp && docker stop myapp_container && docker rm myapp_container && docker run --name myapp_container -d -p 3000:3000 -p 8086:8086 --shm-size=2g myapp
```

Additional parts of the script to include: 

```shell
docker logs -f --until=2s -name myapp_container
```

Clean Up: 

```shell
docker system prune all -a
```

Here is how it would look: 

An updated version of the script that includes checks to ensure each step completes successfully before moving on to the next. 

```shell
#!/bin/bash

# Variables
IMAGE_NAME="myapp"
CONTAINER_NAME="myapp_container"
PORTS="-p 3000:3000 -p 8086:8086"
SHM_SIZE="2g"

# Build the Docker image
echo "Building Docker image..."
docker build . -t $IMAGE_NAME
if [ $? -ne 0 ]; then
    echo "Failed to build Docker image."
    exit 1
fi

# Stop the running container if it exists
if [ $(docker ps -q -f name=$CONTAINER_NAME) ]; then
    echo "Stopping running container..."
    docker stop $CONTAINER_NAME
    if [ $? -ne 0 ]; then
        echo "Failed to stop container $CONTAINER_NAME."
        exit 1
    fi
else
    echo "No running container named $CONTAINER_NAME found."
fi

# Remove the container if it exists
if [ $(docker ps -a -q -f name=$CONTAINER_NAME) ]; then
    echo "Removing existing container..."
    docker rm $CONTAINER_NAME
    if [ $? -ne 0 ]; then
        echo "Failed to remove container $CONTAINER_NAME."
        exit 1
    fi
else
    echo "No existing container named $CONTAINER_NAME found."
fi

# Run a new container
echo "Running a new container..."
docker run --name $CONTAINER_NAME -d $PORTS --shm-size=$SHM_SIZE $IMAGE_NAME
if [ $? -ne 0 ]; then
    echo "Failed to run the container."
    exit 1
fi

echo "Container $CONTAINER_NAME is up and running."
```

This script includes the following enhancements:
1. **Variables:** Defined variables for the image name, container name, ports, and shared memory size for easier adjustments.
2. **Build Step:** Checks if the Docker image builds successfully.
3. **Stop Container Step:** Checks if the container is running before attempting to stop it and ensures the stop operation is successful.
4. **Remove Container Step:** Checks if the container exists before attempting to remove it and ensures the removal operation is successful.
5. **Run Container Step:** Runs a new container and checks if the operation is successful.

Save this script to a file, for example, `docker_manage.sh`, make it executable with `chmod +x docker_manage.sh`, and then run it with `./docker_manage.sh`.


---

<Giscus />