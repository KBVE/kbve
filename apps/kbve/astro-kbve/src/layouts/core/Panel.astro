---
import StaticLeft from "./panels/StaticLeft.astro"
---

<div id="panels-root" class="pointer-events-none">
	<div
		id="panel-top"
		class="panel fixed inset-x-0 top-0 h-64 translate-y-[-100%]">
	</div>
	<div
		id="panel-right"
		class="panel fixed inset-y-0 right-0 w-64 translate-x-[100%]">
	</div>
	<div
		id="panel-bottom"
		class="panel fixed inset-x-0 bottom-0 h-64 translate-y-[100%]">
	</div>
	<div
		id="panel-left"
		class="panel fixed inset-y-0 left-0 w-screen md:w-96 translate-x-[-100%]">
		<StaticLeft />
	</div>
</div>

<script is:inline>
	document.addEventListener('DOMContentLoaded', () => {
		const sides = ['top', 'right', 'bottom', 'left'];
		const panels = Object.fromEntries(
			sides.map((side) => [
				side,
				document.getElementById(`panel-${side}`),
			])
		);

		const transitionClasses = [
			'transition-transform',
			'duration-300',
			'ease-in-out',
			'pointer-events-auto',
			'bg-white/90',
			'dark:bg-neutral-900/90',
			'backdrop-blur-md',
			'shadow-lg',
			'z-[100]',
			'overflow-auto',
			'border',
			'border-white/10',
		];

		function getTransformClass(side, hide) {
			const map = {
				left: ['translate-x-[-100%]', 'translate-x-0'],
				right: ['translate-x-[100%]', 'translate-x-0'],
				top: ['translate-y-[-100%]', 'translate-y-0'],
				bottom: ['translate-y-[100%]', 'translate-y-0'],
			};
			return map[side][hide ? 0 : 1];
		}

		function updatePanels(state) {
			for (const side of sides) {
				const panelState = state.panelManager?.[side];
				const panel = panels[side];
				if (!panel || !panelState) continue;

				// Ensure consistent static classes
				panel.classList.add('panel', 'fixed', ...transitionClasses);

				// Layout position (non-destructive)
				if (side === 'left')
					panel.classList.add(
						'inset-y-0',
						'left-0',
						'w-screen',
						'md:w-96'
					);
				if (side === 'right')
					panel.classList.add(
						'inset-y-0',
						'right-0',
						'w-screen',
						'md:w-96'
					);
				if (side === 'top')
					panel.classList.add('inset-x-0', 'top-0', 'h-64');
				if (side === 'bottom')
					panel.classList.add('inset-x-0', 'bottom-0', 'h-64');

				// Manage transform visibility
				panel.classList.remove(
					'translate-x-[-100%]',
					'translate-x-[100%]',
					'translate-x-0',
					'translate-y-[-100%]',
					'translate-y-[100%]',
					'translate-y-0'
				);
				panel.classList.add(getTransformClass(side, !panelState.open));

				// Setup content region
				let content = panel.querySelector('.panel-content');
				if (!content) {
					content = document.createElement('div');
					content.className =
						'panel-content p-4 text-neutral-800 dark:text-neutral-200';
					const staticBlock = panel.querySelector('.panel-static');
					if (staticBlock?.nextSibling) {
						staticBlock.parentNode.insertBefore(
							content,
							staticBlock.nextSibling
						);
					} else {
						panel.appendChild(content);
					}
				}

				// Only update content if it changed
				const incomingHtml = panelState.payload?.rawHtml ?? '';
				const currentHtml = content.getAttribute('data-html') ?? '';
				if (incomingHtml !== currentHtml) {
					content.innerHTML = incomingHtml;
					content.setAttribute('data-html', incomingHtml);
				}

				// Insert header once
				if (!panel.hasAttribute('data-header-initialized')) {
					const header = document.createElement('div');
					header.className =
						'panel-header flex justify-between items-center p-4 border-b border-white/10 font-bold text-neutral-700 dark:text-white';
					header.innerHTML = `
            <span class="uppercase text-sm tracking-wide">${side} Panel</span>
            <button onclick="window.kbve?.uiux?.closePanel?.('${side}')" class="text-red-500 hover:text-red-400 text-lg">&times;</button>
          `;
					panel.insertBefore(header, content);
					panel.setAttribute('data-header-initialized', 'true');
				}
			}
		}

		function waitForKbve(callback) {
			if ('requestIdleCallback' in window) {
				requestIdleCallback(() => {
					if (window.kbve?.uiux?.state?.subscribe) {
						callback(window.kbve.uiux.state);
					} else {
						setTimeout(() => waitForKbve(callback), 50);
					}
				});
			} else {
				const interval = setInterval(() => {
					if (window.kbve?.uiux?.state?.subscribe) {
						clearInterval(interval);
						callback(window.kbve.uiux.state);
					}
				}, 100);
			}
		}

		waitForKbve((state) => {
			updatePanels(state.get());
			state.subscribe(updatePanels);
			console.log('[Panels] Reactive binding initialized');
		});
	});
</script>
